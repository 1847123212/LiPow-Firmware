
USB PD Charger Rev 02.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000bc  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000020fc  080000c0  080000c0  000100c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000090  080021bc  080021bc  000121bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  0800224c  0800224c  0001224c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08002250  08002250  00012250  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         0000000c  20000000  08002254  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000e0c  2000000c  08002260  0002000c  2**2
                  ALLOC
  7 ._user_heap_stack 00000600  20000e18  08002260  00020e18  2**0
                  ALLOC
  8 .ARM.attributes 00000028  00000000  00000000  0002000c  2**0
                  CONTENTS, READONLY
  9 .debug_info   00013784  00000000  00000000  00020034  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00002f2c  00000000  00000000  000337b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00009a87  00000000  00000000  000366e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00000d40  00000000  00000000  00040170  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000013d0  00000000  00000000  00040eb0  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   000070fb  00000000  00000000  00042280  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00005790  00000000  00000000  0004937b  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .comment      0000007c  00000000  00000000  0004eb0b  2**0
                  CONTENTS, READONLY
 17 .debug_frame  000026fc  00000000  00000000  0004eb88  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	2000000c 	.word	0x2000000c
 80000e0:	00000000 	.word	0x00000000
 80000e4:	080021a4 	.word	0x080021a4

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	20000010 	.word	0x20000010
 8000104:	080021a4 	.word	0x080021a4

08000108 <__udivsi3>:
 8000108:	2200      	movs	r2, #0
 800010a:	0843      	lsrs	r3, r0, #1
 800010c:	428b      	cmp	r3, r1
 800010e:	d374      	bcc.n	80001fa <__udivsi3+0xf2>
 8000110:	0903      	lsrs	r3, r0, #4
 8000112:	428b      	cmp	r3, r1
 8000114:	d35f      	bcc.n	80001d6 <__udivsi3+0xce>
 8000116:	0a03      	lsrs	r3, r0, #8
 8000118:	428b      	cmp	r3, r1
 800011a:	d344      	bcc.n	80001a6 <__udivsi3+0x9e>
 800011c:	0b03      	lsrs	r3, r0, #12
 800011e:	428b      	cmp	r3, r1
 8000120:	d328      	bcc.n	8000174 <__udivsi3+0x6c>
 8000122:	0c03      	lsrs	r3, r0, #16
 8000124:	428b      	cmp	r3, r1
 8000126:	d30d      	bcc.n	8000144 <__udivsi3+0x3c>
 8000128:	22ff      	movs	r2, #255	; 0xff
 800012a:	0209      	lsls	r1, r1, #8
 800012c:	ba12      	rev	r2, r2
 800012e:	0c03      	lsrs	r3, r0, #16
 8000130:	428b      	cmp	r3, r1
 8000132:	d302      	bcc.n	800013a <__udivsi3+0x32>
 8000134:	1212      	asrs	r2, r2, #8
 8000136:	0209      	lsls	r1, r1, #8
 8000138:	d065      	beq.n	8000206 <__udivsi3+0xfe>
 800013a:	0b03      	lsrs	r3, r0, #12
 800013c:	428b      	cmp	r3, r1
 800013e:	d319      	bcc.n	8000174 <__udivsi3+0x6c>
 8000140:	e000      	b.n	8000144 <__udivsi3+0x3c>
 8000142:	0a09      	lsrs	r1, r1, #8
 8000144:	0bc3      	lsrs	r3, r0, #15
 8000146:	428b      	cmp	r3, r1
 8000148:	d301      	bcc.n	800014e <__udivsi3+0x46>
 800014a:	03cb      	lsls	r3, r1, #15
 800014c:	1ac0      	subs	r0, r0, r3
 800014e:	4152      	adcs	r2, r2
 8000150:	0b83      	lsrs	r3, r0, #14
 8000152:	428b      	cmp	r3, r1
 8000154:	d301      	bcc.n	800015a <__udivsi3+0x52>
 8000156:	038b      	lsls	r3, r1, #14
 8000158:	1ac0      	subs	r0, r0, r3
 800015a:	4152      	adcs	r2, r2
 800015c:	0b43      	lsrs	r3, r0, #13
 800015e:	428b      	cmp	r3, r1
 8000160:	d301      	bcc.n	8000166 <__udivsi3+0x5e>
 8000162:	034b      	lsls	r3, r1, #13
 8000164:	1ac0      	subs	r0, r0, r3
 8000166:	4152      	adcs	r2, r2
 8000168:	0b03      	lsrs	r3, r0, #12
 800016a:	428b      	cmp	r3, r1
 800016c:	d301      	bcc.n	8000172 <__udivsi3+0x6a>
 800016e:	030b      	lsls	r3, r1, #12
 8000170:	1ac0      	subs	r0, r0, r3
 8000172:	4152      	adcs	r2, r2
 8000174:	0ac3      	lsrs	r3, r0, #11
 8000176:	428b      	cmp	r3, r1
 8000178:	d301      	bcc.n	800017e <__udivsi3+0x76>
 800017a:	02cb      	lsls	r3, r1, #11
 800017c:	1ac0      	subs	r0, r0, r3
 800017e:	4152      	adcs	r2, r2
 8000180:	0a83      	lsrs	r3, r0, #10
 8000182:	428b      	cmp	r3, r1
 8000184:	d301      	bcc.n	800018a <__udivsi3+0x82>
 8000186:	028b      	lsls	r3, r1, #10
 8000188:	1ac0      	subs	r0, r0, r3
 800018a:	4152      	adcs	r2, r2
 800018c:	0a43      	lsrs	r3, r0, #9
 800018e:	428b      	cmp	r3, r1
 8000190:	d301      	bcc.n	8000196 <__udivsi3+0x8e>
 8000192:	024b      	lsls	r3, r1, #9
 8000194:	1ac0      	subs	r0, r0, r3
 8000196:	4152      	adcs	r2, r2
 8000198:	0a03      	lsrs	r3, r0, #8
 800019a:	428b      	cmp	r3, r1
 800019c:	d301      	bcc.n	80001a2 <__udivsi3+0x9a>
 800019e:	020b      	lsls	r3, r1, #8
 80001a0:	1ac0      	subs	r0, r0, r3
 80001a2:	4152      	adcs	r2, r2
 80001a4:	d2cd      	bcs.n	8000142 <__udivsi3+0x3a>
 80001a6:	09c3      	lsrs	r3, r0, #7
 80001a8:	428b      	cmp	r3, r1
 80001aa:	d301      	bcc.n	80001b0 <__udivsi3+0xa8>
 80001ac:	01cb      	lsls	r3, r1, #7
 80001ae:	1ac0      	subs	r0, r0, r3
 80001b0:	4152      	adcs	r2, r2
 80001b2:	0983      	lsrs	r3, r0, #6
 80001b4:	428b      	cmp	r3, r1
 80001b6:	d301      	bcc.n	80001bc <__udivsi3+0xb4>
 80001b8:	018b      	lsls	r3, r1, #6
 80001ba:	1ac0      	subs	r0, r0, r3
 80001bc:	4152      	adcs	r2, r2
 80001be:	0943      	lsrs	r3, r0, #5
 80001c0:	428b      	cmp	r3, r1
 80001c2:	d301      	bcc.n	80001c8 <__udivsi3+0xc0>
 80001c4:	014b      	lsls	r3, r1, #5
 80001c6:	1ac0      	subs	r0, r0, r3
 80001c8:	4152      	adcs	r2, r2
 80001ca:	0903      	lsrs	r3, r0, #4
 80001cc:	428b      	cmp	r3, r1
 80001ce:	d301      	bcc.n	80001d4 <__udivsi3+0xcc>
 80001d0:	010b      	lsls	r3, r1, #4
 80001d2:	1ac0      	subs	r0, r0, r3
 80001d4:	4152      	adcs	r2, r2
 80001d6:	08c3      	lsrs	r3, r0, #3
 80001d8:	428b      	cmp	r3, r1
 80001da:	d301      	bcc.n	80001e0 <__udivsi3+0xd8>
 80001dc:	00cb      	lsls	r3, r1, #3
 80001de:	1ac0      	subs	r0, r0, r3
 80001e0:	4152      	adcs	r2, r2
 80001e2:	0883      	lsrs	r3, r0, #2
 80001e4:	428b      	cmp	r3, r1
 80001e6:	d301      	bcc.n	80001ec <__udivsi3+0xe4>
 80001e8:	008b      	lsls	r3, r1, #2
 80001ea:	1ac0      	subs	r0, r0, r3
 80001ec:	4152      	adcs	r2, r2
 80001ee:	0843      	lsrs	r3, r0, #1
 80001f0:	428b      	cmp	r3, r1
 80001f2:	d301      	bcc.n	80001f8 <__udivsi3+0xf0>
 80001f4:	004b      	lsls	r3, r1, #1
 80001f6:	1ac0      	subs	r0, r0, r3
 80001f8:	4152      	adcs	r2, r2
 80001fa:	1a41      	subs	r1, r0, r1
 80001fc:	d200      	bcs.n	8000200 <__udivsi3+0xf8>
 80001fe:	4601      	mov	r1, r0
 8000200:	4152      	adcs	r2, r2
 8000202:	4610      	mov	r0, r2
 8000204:	4770      	bx	lr
 8000206:	e7ff      	b.n	8000208 <__udivsi3+0x100>
 8000208:	b501      	push	{r0, lr}
 800020a:	2000      	movs	r0, #0
 800020c:	f000 f806 	bl	800021c <__aeabi_idiv0>
 8000210:	bd02      	pop	{r1, pc}
 8000212:	46c0      	nop			; (mov r8, r8)

08000214 <__aeabi_uidivmod>:
 8000214:	2900      	cmp	r1, #0
 8000216:	d0f7      	beq.n	8000208 <__udivsi3+0x100>
 8000218:	e776      	b.n	8000108 <__udivsi3>
 800021a:	4770      	bx	lr

0800021c <__aeabi_idiv0>:
 800021c:	4770      	bx	lr
 800021e:	46c0      	nop			; (mov r8, r8)

08000220 <HAL_Init>:
#if (INSTRUCTION_CACHE_ENABLE == 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000220:	2380      	movs	r3, #128	; 0x80
 8000222:	4a08      	ldr	r2, [pc, #32]	; (8000244 <HAL_Init+0x24>)
 8000224:	005b      	lsls	r3, r3, #1
 8000226:	6811      	ldr	r1, [r2, #0]
{
 8000228:	b510      	push	{r4, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800022a:	430b      	orrs	r3, r1
 800022c:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 800022e:	2000      	movs	r0, #0
 8000230:	f001 ff14 	bl	800205c <HAL_InitTick>
 8000234:	1e04      	subs	r4, r0, #0
 8000236:	d103      	bne.n	8000240 <HAL_Init+0x20>
    status = HAL_ERROR;
  }
  else
  {
  /* Init the low level hardware */
  HAL_MspInit();
 8000238:	f001 fec6 	bl	8001fc8 <HAL_MspInit>
  }

  /* Return function status */
  return status;
}
 800023c:	0020      	movs	r0, r4
 800023e:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 8000240:	2401      	movs	r4, #1
 8000242:	e7fb      	b.n	800023c <HAL_Init+0x1c>
 8000244:	40022000 	.word	0x40022000

08000248 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8000248:	4a03      	ldr	r2, [pc, #12]	; (8000258 <HAL_IncTick+0x10>)
 800024a:	4904      	ldr	r1, [pc, #16]	; (800025c <HAL_IncTick+0x14>)
 800024c:	6813      	ldr	r3, [r2, #0]
 800024e:	6809      	ldr	r1, [r1, #0]
 8000250:	185b      	adds	r3, r3, r1
 8000252:	6013      	str	r3, [r2, #0]
}
 8000254:	4770      	bx	lr
 8000256:	46c0      	nop			; (mov r8, r8)
 8000258:	20000d6c 	.word	0x20000d6c
 800025c:	20000000 	.word	0x20000000

08000260 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000260:	4b01      	ldr	r3, [pc, #4]	; (8000268 <HAL_GetTick+0x8>)
 8000262:	6818      	ldr	r0, [r3, #0]
}
 8000264:	4770      	bx	lr
 8000266:	46c0      	nop			; (mov r8, r8)
 8000268:	20000d6c 	.word	0x20000d6c

0800026c <LL_ADC_REG_IsConversionOngoing>:
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 800026c:	6880      	ldr	r0, [r0, #8]
 800026e:	0740      	lsls	r0, r0, #29
 8000270:	0fc0      	lsrs	r0, r0, #31
}
 8000272:	4770      	bx	lr

08000274 <HAL_ADC_Init>:
{
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpCFGR1 = 0UL;
  uint32_t tmpCFGR2 = 0UL;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 8000274:	2300      	movs	r3, #0
{
 8000276:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000278:	b085      	sub	sp, #20
 800027a:	0004      	movs	r4, r0
  __IO uint32_t wait_loop_index = 0UL;
 800027c:	9303      	str	r3, [sp, #12]
  
  /* Check ADC handle */
  if(hadc == NULL)
  {
    return HAL_ERROR;
 800027e:	2501      	movs	r5, #1
  if(hadc == NULL)
 8000280:	4298      	cmp	r0, r3
 8000282:	d100      	bne.n	8000286 <HAL_ADC_Init+0x12>
 8000284:	e09a      	b.n	80003bc <HAL_ADC_Init+0x148>
  /* continuous mode is disabled.                                             */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));
  
  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if(hadc->State == HAL_ADC_STATE_RESET)
 8000286:	6d85      	ldr	r5, [r0, #88]	; 0x58
 8000288:	429d      	cmp	r5, r3
 800028a:	d105      	bne.n	8000298 <HAL_ADC_Init+0x24>
    
    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 800028c:	f001 feb8 	bl	8002000 <HAL_ADC_MspInit>
    
    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
    
    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 8000290:	0023      	movs	r3, r4
 8000292:	3354      	adds	r3, #84	; 0x54
    ADC_CLEAR_ERRORCODE(hadc);
 8000294:	65e5      	str	r5, [r4, #92]	; 0x5c
    hadc->Lock = HAL_UNLOCKED;
 8000296:	701d      	strb	r5, [r3, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8000298:	2380      	movs	r3, #128	; 0x80
  }
  
  if(LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 800029a:	6826      	ldr	r6, [r4, #0]
 800029c:	055b      	lsls	r3, r3, #21
 800029e:	68b2      	ldr	r2, [r6, #8]
 80002a0:	421a      	tst	r2, r3
 80002a2:	d100      	bne.n	80002a6 <HAL_ADC_Init+0x32>
 80002a4:	e0d0      	b.n	8000448 <HAL_ADC_Init+0x1d4>
 80002a6:	68b3      	ldr	r3, [r6, #8]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80002a8:	2500      	movs	r5, #0
 80002aa:	00db      	lsls	r3, r3, #3
 80002ac:	d400      	bmi.n	80002b0 <HAL_ADC_Init+0x3c>
 80002ae:	e0d8      	b.n	8000462 <HAL_ADC_Init+0x1ee>
  
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 80002b0:	0030      	movs	r0, r6
 80002b2:	f7ff ffdb 	bl	800026c <LL_ADC_REG_IsConversionOngoing>
  
  if(   ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 80002b6:	2310      	movs	r3, #16
 80002b8:	6da6      	ldr	r6, [r4, #88]	; 0x58
 80002ba:	401e      	ands	r6, r3
 80002bc:	d000      	beq.n	80002c0 <HAL_ADC_Init+0x4c>
 80002be:	e0be      	b.n	800043e <HAL_ADC_Init+0x1ca>
     && (tmp_adc_reg_is_conversion_on_going == 0UL)
 80002c0:	2800      	cmp	r0, #0
 80002c2:	d000      	beq.n	80002c6 <HAL_ADC_Init+0x52>
 80002c4:	e0bb      	b.n	800043e <HAL_ADC_Init+0x1ca>
    )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 80002c6:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80002c8:	4a7c      	ldr	r2, [pc, #496]	; (80004bc <HAL_ADC_Init+0x248>)
 80002ca:	401a      	ands	r2, r3
 80002cc:	2302      	movs	r3, #2
 80002ce:	4313      	orrs	r3, r2
 80002d0:	65a3      	str	r3, [r4, #88]	; 0x58
    /*  - Clock configuration                                                 */
    /*  - ADC resolution                                                      */
    /* Note: If low power mode AutoPowerOff is enabled, ADC enable            */
    /*       and disable phases are performed automatically by hardware       */
    /*       (in this case, flag ADC_FLAG_RDY is not set).                    */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 80002d2:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80002d4:	689a      	ldr	r2, [r3, #8]
 80002d6:	07d2      	lsls	r2, r2, #31
 80002d8:	d400      	bmi.n	80002dc <HAL_ADC_Init+0x68>
 80002da:	e0cb      	b.n	8000474 <HAL_ADC_Init+0x200>
    /*  - scan direction                                                      */
    /*  - DMA continuous request                                              */
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
                 ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)     |
                 ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)    |
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                            |
 80002dc:	6b27      	ldr	r7, [r4, #48]	; 0x30
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 80002de:	7e21      	ldrb	r1, [r4, #24]
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                            |
 80002e0:	1e78      	subs	r0, r7, #1
 80002e2:	4187      	sbcs	r7, r0
                 ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)     |
 80002e4:	7e62      	ldrb	r2, [r4, #25]
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                            |
 80002e6:	0338      	lsls	r0, r7, #12
                 ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)     |
 80002e8:	03d2      	lsls	r2, r2, #15
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 80002ea:	0389      	lsls	r1, r1, #14
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                            |
 80002ec:	9001      	str	r0, [sp, #4]
 80002ee:	68e0      	ldr	r0, [r4, #12]
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 80002f0:	4311      	orrs	r1, r2
                 ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)    |
 80002f2:	7ea2      	ldrb	r2, [r4, #26]
 80002f4:	4301      	orrs	r1, r0
                 hadc->Init.DataAlign                                             |
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                       |
 80002f6:	6920      	ldr	r0, [r4, #16]
                 ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)    |
 80002f8:	4694      	mov	ip, r2
 80002fa:	0352      	lsls	r2, r2, #13
 80002fc:	4311      	orrs	r1, r2
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                       |
 80002fe:	2800      	cmp	r0, #0
 8000300:	da66      	bge.n	80003d0 <HAL_ADC_Init+0x15c>
 8000302:	0047      	lsls	r7, r0, #1
 8000304:	087f      	lsrs	r7, r7, #1
                 ADC_CFGR1_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests)  );
 8000306:	0022      	movs	r2, r4
 8000308:	322c      	adds	r2, #44	; 0x2c
 800030a:	7812      	ldrb	r2, [r2, #0]
 800030c:	0052      	lsls	r2, r2, #1
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                       |
 800030e:	430a      	orrs	r2, r1
 8000310:	9901      	ldr	r1, [sp, #4]
 8000312:	430a      	orrs	r2, r1
 8000314:	4317      	orrs	r7, r2
 8000316:	9701      	str	r7, [sp, #4]
    
    /* Update setting of discontinuous mode only if continuous mode is disabled */
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8000318:	1c62      	adds	r2, r4, #1
 800031a:	7fd2      	ldrb	r2, [r2, #31]
 800031c:	2a01      	cmp	r2, #1
 800031e:	d107      	bne.n	8000330 <HAL_ADC_Init+0xbc>
    {
      if (hadc->Init.ContinuousConvMode == DISABLE)
 8000320:	4661      	mov	r1, ip
 8000322:	2900      	cmp	r1, #0
 8000324:	d157      	bne.n	80003d6 <HAL_ADC_Init+0x162>
      {
        /* Enable the selected ADC group regular discontinuous mode */
        tmpCFGR1 |= ADC_CFGR1_DISCEN;
 8000326:	2280      	movs	r2, #128	; 0x80
 8000328:	0039      	movs	r1, r7
 800032a:	0252      	lsls	r2, r2, #9
 800032c:	4311      	orrs	r1, r2
 800032e:	9101      	str	r1, [sp, #4]
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8000330:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8000332:	2a00      	cmp	r2, #0
 8000334:	d007      	beq.n	8000346 <HAL_ADC_Init+0xd2>
    {
      tmpCFGR1 |= ( (hadc->Init.ExternalTrigConv & ADC_CFGR1_EXTSEL) |
 8000336:	21e0      	movs	r1, #224	; 0xe0
 8000338:	0049      	lsls	r1, r1, #1
 800033a:	400a      	ands	r2, r1
 800033c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800033e:	430a      	orrs	r2, r1
 8000340:	9901      	ldr	r1, [sp, #4]
 8000342:	4311      	orrs	r1, r2
 8000344:	9101      	str	r1, [sp, #4]
    /*  - oversampling enable                                                 */
    /*  - oversampling ratio                                                  */
    /*  - oversampling shift                                                  */
    /*  - oversampling discontinuous mode (triggered mode)                    */
    /*  - trigger frequency mode                                              */
    tmpCFGR2 |= ( hadc->Init.Oversampling.Ratio         |
 8000346:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8000348:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800034a:	430a      	orrs	r2, r1
                  hadc->Init.Oversampling.RightBitShift |
 800034c:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800034e:	430a      	orrs	r2, r1
                  hadc->Init.Oversampling.TriggeredMode |
 8000350:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 8000352:	430a      	orrs	r2, r1
                  hadc->Init.TriggerFrequencyMode
                  );
    
    if (hadc->Init.OversamplingMode == ENABLE)
 8000354:	0021      	movs	r1, r4
 8000356:	313c      	adds	r1, #60	; 0x3c
 8000358:	7809      	ldrb	r1, [r1, #0]
 800035a:	2901      	cmp	r1, #1
 800035c:	d100      	bne.n	8000360 <HAL_ADC_Init+0xec>
    {
      SET_BIT(tmpCFGR2, ADC_CFGR2_OVSE);
 800035e:	430a      	orrs	r2, r1
    }
    
    /* Update ADC configuration register with previous settings */
    MODIFY_REG(hadc->Instance->CFGR1,
 8000360:	68d9      	ldr	r1, [r3, #12]
 8000362:	4f57      	ldr	r7, [pc, #348]	; (80004c0 <HAL_ADC_Init+0x24c>)
 8000364:	4039      	ands	r1, r7
 8000366:	9f01      	ldr	r7, [sp, #4]
 8000368:	4339      	orrs	r1, r7
 800036a:	60d9      	str	r1, [r3, #12]
               ADC_CFGR1_ALIGN   |
               ADC_CFGR1_SCANDIR |
               ADC_CFGR1_DMACFG     ,
               tmpCFGR1              );
    
    MODIFY_REG(hadc->Instance->CFGR2,
 800036c:	6919      	ldr	r1, [r3, #16]
 800036e:	4f55      	ldr	r7, [pc, #340]	; (80004c4 <HAL_ADC_Init+0x250>)
 8000370:	4039      	ands	r1, r7
 8000372:	430a      	orrs	r2, r1
  MODIFY_REG(ADCx->SMPR,
 8000374:	2107      	movs	r1, #7
 8000376:	2770      	movs	r7, #112	; 0x70
 8000378:	611a      	str	r2, [r3, #16]
 800037a:	695a      	ldr	r2, [r3, #20]
 800037c:	438a      	bics	r2, r1
 800037e:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8000380:	430a      	orrs	r2, r1
 8000382:	615a      	str	r2, [r3, #20]
 8000384:	695a      	ldr	r2, [r3, #20]
 8000386:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8000388:	43ba      	bics	r2, r7
 800038a:	0109      	lsls	r1, r1, #4
 800038c:	430a      	orrs	r2, r1
 800038e:	615a      	str	r2, [r3, #20]
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */
    /*   Channels must be configured into each rank using function            */
    /*   "HAL_ADC_ConfigChannel()".                                           */
    if(hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)
 8000390:	2800      	cmp	r0, #0
 8000392:	d12a      	bne.n	80003ea <HAL_ADC_Init+0x176>
      if(ADCGroupRegularSequencerRanksCount == 1UL)
      {
        /* Set ADC group regular sequencer:                                   */
        /* Set sequencer scan length by clearing ranks above rank 1           */
        /* and do not modify rank 1 value.                                    */
        SET_BIT(hadc->Instance->CHSELR,
 8000394:	2210      	movs	r2, #16
 8000396:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8000398:	4252      	negs	r2, r2
        /*          therefore afer the first call of "HAL_ADC_Init()",        */
        /*          each rank corresponding to parameter "NbrOfConversion"    */
        /*          must be set using "HAL_ADC_ConfigChannel()".              */
        /*  - Set sequencer scan length by clearing ranks above maximum rank  */
        /*    and do not modify other ranks value.                            */
        MODIFY_REG(hadc->Instance->CHSELR,
 800039a:	430a      	orrs	r2, r1
 800039c:	629a      	str	r2, [r3, #40]	; 0x28
    /* Check back that ADC registers have effectively been configured to      */
    /* ensure of no potential problem of ADC core IP clocking.                */
    /* Check through register CFGR1 (excluding analog watchdog configuration: */
    /* set into separate dedicated function, and bits of ADC resolution set   */
    /* out of temporary variable 'tmpCFGR1').                                 */
    if ((hadc->Instance->CFGR1 & ~(ADC_CFGR1_AWD1CH | ADC_CFGR1_AWD1EN | ADC_CFGR1_AWD1SGL | ADC_CFGR1_RES))
 800039e:	4a4a      	ldr	r2, [pc, #296]	; (80004c8 <HAL_ADC_Init+0x254>)
 80003a0:	68db      	ldr	r3, [r3, #12]
 80003a2:	4013      	ands	r3, r2
 80003a4:	9a01      	ldr	r2, [sp, #4]
 80003a6:	429a      	cmp	r2, r3
 80003a8:	d13d      	bne.n	8000426 <HAL_ADC_Init+0x1b2>
         == tmpCFGR1)
    {
      /* Set ADC error code to none */
      ADC_CLEAR_ERRORCODE(hadc);
 80003aa:	2300      	movs	r3, #0
      
      /* Set the ADC state */
      ADC_STATE_CLR_SET(hadc->State,
 80003ac:	2203      	movs	r2, #3
      ADC_CLEAR_ERRORCODE(hadc);
 80003ae:	65e3      	str	r3, [r4, #92]	; 0x5c
      ADC_STATE_CLR_SET(hadc->State,
 80003b0:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80003b2:	4393      	bics	r3, r2
 80003b4:	001a      	movs	r2, r3
 80003b6:	2301      	movs	r3, #1
 80003b8:	4313      	orrs	r3, r2
 80003ba:	65a3      	str	r3, [r4, #88]	; 0x58
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Return function status */
  return tmp_hal_status;
}
 80003bc:	0028      	movs	r0, r5
 80003be:	b005      	add	sp, #20
 80003c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
      wait_loop_index--;
 80003c2:	9b03      	ldr	r3, [sp, #12]
 80003c4:	3b01      	subs	r3, #1
 80003c6:	9303      	str	r3, [sp, #12]
    while(wait_loop_index != 0UL)
 80003c8:	9b03      	ldr	r3, [sp, #12]
 80003ca:	2b00      	cmp	r3, #0
 80003cc:	d1f9      	bne.n	80003c2 <HAL_ADC_Init+0x14e>
 80003ce:	e76a      	b.n	80002a6 <HAL_ADC_Init+0x32>
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                       |
 80003d0:	2780      	movs	r7, #128	; 0x80
 80003d2:	03bf      	lsls	r7, r7, #14
 80003d4:	e797      	b.n	8000306 <HAL_ADC_Init+0x92>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80003d6:	6da1      	ldr	r1, [r4, #88]	; 0x58
 80003d8:	468c      	mov	ip, r1
 80003da:	2120      	movs	r1, #32
 80003dc:	4667      	mov	r7, ip
 80003de:	4339      	orrs	r1, r7
 80003e0:	65a1      	str	r1, [r4, #88]	; 0x58
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80003e2:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 80003e4:	430a      	orrs	r2, r1
 80003e6:	65e2      	str	r2, [r4, #92]	; 0x5c
 80003e8:	e7a2      	b.n	8000330 <HAL_ADC_Init+0xbc>
    else if(hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 80003ea:	2280      	movs	r2, #128	; 0x80
 80003ec:	0392      	lsls	r2, r2, #14
 80003ee:	4290      	cmp	r0, r2
 80003f0:	d1d5      	bne.n	800039e <HAL_ADC_Init+0x12a>
        if(((hadc->ADCGroupRegularSequencerRanks >> (ADCGroupRegularSequencerRanksCount * 4UL)) & ADC_CHSELR_SQ1) == ADC_CHSELR_SQ1)
 80003f2:	200f      	movs	r0, #15
 80003f4:	6e21      	ldr	r1, [r4, #96]	; 0x60
 80003f6:	000f      	movs	r7, r1
 80003f8:	00b2      	lsls	r2, r6, #2
 80003fa:	40d7      	lsrs	r7, r2
 80003fc:	003a      	movs	r2, r7
 80003fe:	4002      	ands	r2, r0
 8000400:	2a0f      	cmp	r2, #15
 8000402:	d00d      	beq.n	8000420 <HAL_ADC_Init+0x1ac>
      for(ADCGroupRegularSequencerRanksCount = 0UL; ADCGroupRegularSequencerRanksCount < (8UL); ADCGroupRegularSequencerRanksCount++)
 8000404:	3601      	adds	r6, #1
 8000406:	2e08      	cmp	r6, #8
 8000408:	d1f5      	bne.n	80003f6 <HAL_ADC_Init+0x182>
        MODIFY_REG(hadc->Instance->CHSELR,
 800040a:	4830      	ldr	r0, [pc, #192]	; (80004cc <HAL_ADC_Init+0x258>)
 800040c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800040e:	69e2      	ldr	r2, [r4, #28]
 8000410:	1812      	adds	r2, r2, r0
 8000412:	201c      	movs	r0, #28
 8000414:	0092      	lsls	r2, r2, #2
 8000416:	4002      	ands	r2, r0
 8000418:	382c      	subs	r0, #44	; 0x2c
 800041a:	4090      	lsls	r0, r2
 800041c:	0002      	movs	r2, r0
 800041e:	e7bc      	b.n	800039a <HAL_ADC_Init+0x126>
      if(ADCGroupRegularSequencerRanksCount == 1UL)
 8000420:	2e01      	cmp	r6, #1
 8000422:	d0b7      	beq.n	8000394 <HAL_ADC_Init+0x120>
 8000424:	e7f1      	b.n	800040a <HAL_ADC_Init+0x196>
      ADC_STATE_CLR_SET(hadc->State,
 8000426:	2212      	movs	r2, #18
 8000428:	6da3      	ldr	r3, [r4, #88]	; 0x58
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800042a:	2501      	movs	r5, #1
      ADC_STATE_CLR_SET(hadc->State,
 800042c:	4393      	bics	r3, r2
 800042e:	001a      	movs	r2, r3
 8000430:	2310      	movs	r3, #16
 8000432:	4313      	orrs	r3, r2
 8000434:	65a3      	str	r3, [r4, #88]	; 0x58
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8000436:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8000438:	432b      	orrs	r3, r5
 800043a:	65e3      	str	r3, [r4, #92]	; 0x5c
 800043c:	e7be      	b.n	80003bc <HAL_ADC_Init+0x148>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800043e:	6da2      	ldr	r2, [r4, #88]	; 0x58
    tmp_hal_status = HAL_ERROR;
 8000440:	2501      	movs	r5, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8000442:	4313      	orrs	r3, r2
 8000444:	65a3      	str	r3, [r4, #88]	; 0x58
 8000446:	e7b9      	b.n	80003bc <HAL_ADC_Init+0x148>
  MODIFY_REG(ADCx->CR,
 8000448:	68b2      	ldr	r2, [r6, #8]
 800044a:	4921      	ldr	r1, [pc, #132]	; (80004d0 <HAL_ADC_Init+0x25c>)
 800044c:	400a      	ands	r2, r1
 800044e:	4313      	orrs	r3, r2
 8000450:	60b3      	str	r3, [r6, #8]
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 8000452:	4b20      	ldr	r3, [pc, #128]	; (80004d4 <HAL_ADC_Init+0x260>)
 8000454:	4920      	ldr	r1, [pc, #128]	; (80004d8 <HAL_ADC_Init+0x264>)
 8000456:	6818      	ldr	r0, [r3, #0]
 8000458:	f7ff fe56 	bl	8000108 <__udivsi3>
 800045c:	0040      	lsls	r0, r0, #1
 800045e:	9003      	str	r0, [sp, #12]
    while(wait_loop_index != 0UL)
 8000460:	e7b2      	b.n	80003c8 <HAL_ADC_Init+0x154>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8000462:	2310      	movs	r3, #16
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8000464:	2501      	movs	r5, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8000466:	6da2      	ldr	r2, [r4, #88]	; 0x58
 8000468:	4313      	orrs	r3, r2
 800046a:	65a3      	str	r3, [r4, #88]	; 0x58
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800046c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800046e:	432b      	orrs	r3, r5
 8000470:	65e3      	str	r3, [r4, #92]	; 0x5c
 8000472:	e71d      	b.n	80002b0 <HAL_ADC_Init+0x3c>
      MODIFY_REG(hadc->Instance->CFGR1,
 8000474:	2118      	movs	r1, #24
 8000476:	68da      	ldr	r2, [r3, #12]
 8000478:	438a      	bics	r2, r1
 800047a:	68a1      	ldr	r1, [r4, #8]
 800047c:	430a      	orrs	r2, r1
 800047e:	60da      	str	r2, [r3, #12]
      MODIFY_REG(hadc->Instance->CFGR2                       ,
 8000480:	6861      	ldr	r1, [r4, #4]
 8000482:	691a      	ldr	r2, [r3, #16]
 8000484:	0f88      	lsrs	r0, r1, #30
 8000486:	0092      	lsls	r2, r2, #2
 8000488:	0780      	lsls	r0, r0, #30
 800048a:	0892      	lsrs	r2, r2, #2
 800048c:	4302      	orrs	r2, r0
      if (((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV1) &&
 800048e:	2080      	movs	r0, #128	; 0x80
      MODIFY_REG(hadc->Instance->CFGR2                       ,
 8000490:	611a      	str	r2, [r3, #16]
      if (((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV1) &&
 8000492:	004a      	lsls	r2, r1, #1
 8000494:	0852      	lsrs	r2, r2, #1
 8000496:	05c0      	lsls	r0, r0, #23
 8000498:	4282      	cmp	r2, r0
 800049a:	d100      	bne.n	800049e <HAL_ADC_Init+0x22a>
 800049c:	e71e      	b.n	80002dc <HAL_ADC_Init+0x68>
          ((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV2) &&
 800049e:	2280      	movs	r2, #128	; 0x80
 80004a0:	0612      	lsls	r2, r2, #24
 80004a2:	4291      	cmp	r1, r2
 80004a4:	d100      	bne.n	80004a8 <HAL_ADC_Init+0x234>
 80004a6:	e719      	b.n	80002dc <HAL_ADC_Init+0x68>
        MODIFY_REG(ADC1_COMMON->CCR                         ,
 80004a8:	480c      	ldr	r0, [pc, #48]	; (80004dc <HAL_ADC_Init+0x268>)
 80004aa:	4f0d      	ldr	r7, [pc, #52]	; (80004e0 <HAL_ADC_Init+0x26c>)
 80004ac:	6802      	ldr	r2, [r0, #0]
 80004ae:	403a      	ands	r2, r7
 80004b0:	27f0      	movs	r7, #240	; 0xf0
 80004b2:	03bf      	lsls	r7, r7, #14
 80004b4:	4039      	ands	r1, r7
 80004b6:	430a      	orrs	r2, r1
 80004b8:	6002      	str	r2, [r0, #0]
 80004ba:	e70f      	b.n	80002dc <HAL_ADC_Init+0x68>
 80004bc:	fffffefd 	.word	0xfffffefd
 80004c0:	fffe0219 	.word	0xfffe0219
 80004c4:	dffffc02 	.word	0xdffffc02
 80004c8:	833fffe7 	.word	0x833fffe7
 80004cc:	3fffffff 	.word	0x3fffffff
 80004d0:	6fffffe8 	.word	0x6fffffe8
 80004d4:	20000008 	.word	0x20000008
 80004d8:	00030d40 	.word	0x00030d40
 80004dc:	40012708 	.word	0x40012708
 80004e0:	ffc3ffff 	.word	0xffc3ffff

080004e4 <HAL_ADC_ConfigChannel>:
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0UL;
 80004e4:	2300      	movs	r3, #0
{
 80004e6:	b5f0      	push	{r4, r5, r6, r7, lr}
 80004e8:	b089      	sub	sp, #36	; 0x24
  __IO uint32_t wait_loop_index = 0UL;
 80004ea:	9307      	str	r3, [sp, #28]
    
    assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  }
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80004ec:	0003      	movs	r3, r0
 80004ee:	3354      	adds	r3, #84	; 0x54
 80004f0:	781a      	ldrb	r2, [r3, #0]
{
 80004f2:	0005      	movs	r5, r0
 80004f4:	000f      	movs	r7, r1
  __HAL_LOCK(hadc);
 80004f6:	2402      	movs	r4, #2
 80004f8:	2a01      	cmp	r2, #1
 80004fa:	d100      	bne.n	80004fe <HAL_ADC_ConfigChannel+0x1a>
 80004fc:	e0c1      	b.n	8000682 <HAL_ADC_ConfigChannel+0x19e>
 80004fe:	2601      	movs	r6, #1
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel sampling time                                                 */
  /*  - Management of internal measurement channels: VrefInt/TempSensor/Vbat  */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8000500:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hadc);
 8000502:	701e      	strb	r6, [r3, #0]
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8000504:	f7ff feb2 	bl	800026c <LL_ADC_REG_IsConversionOngoing>
 8000508:	9003      	str	r0, [sp, #12]
 800050a:	2800      	cmp	r0, #0
 800050c:	d000      	beq.n	8000510 <HAL_ADC_ConfigChannel+0x2c>
 800050e:	e0ef      	b.n	80006f0 <HAL_ADC_ConfigChannel+0x20c>
 8000510:	2204      	movs	r2, #4
 8000512:	2180      	movs	r1, #128	; 0x80
    /* If sequencer set to not fully configurable with channel rank set to    */
    /* none, remove the channel from the sequencer.                           */
    /* Otherwise (sequencer set to fully configurable or to to not fully      */
    /* configurable with channel rank to be set), configure the selected      */
    /* channel.                                                               */
    if(sConfig->Rank != ADC_RANK_NONE)
 8000514:	687b      	ldr	r3, [r7, #4]
 8000516:	4694      	mov	ip, r2
 8000518:	9301      	str	r3, [sp, #4]
 800051a:	9801      	ldr	r0, [sp, #4]
 800051c:	692b      	ldr	r3, [r5, #16]
 800051e:	0609      	lsls	r1, r1, #24
 8000520:	683a      	ldr	r2, [r7, #0]
 8000522:	42a0      	cmp	r0, r4
 8000524:	d100      	bne.n	8000528 <HAL_ADC_ConfigChannel+0x44>
 8000526:	e0b6      	b.n	8000696 <HAL_ADC_ConfigChannel+0x1b2>
      /* Note: ADC channel configuration requires few ADC clock cycles        */
      /*       to be ready. Processing of ADC settings in this function       */
      /*       induce that a specific wait time is not necessary.             */
      /*       For more details on ADC channel configuration ready,           */
      /*       refer to function "LL_ADC_IsActiveFlag_CCRDY()".               */
      if((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)         ||
 8000528:	4660      	mov	r0, ip
 800052a:	4383      	bics	r3, r0
 800052c:	428b      	cmp	r3, r1
 800052e:	d113      	bne.n	8000558 <HAL_ADC_ConfigChannel+0x74>
         (hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED_BACKWARD)  )
      {
        /* Sequencer set to not fully configurable:                           */
        /* Set the channel by enabling the corresponding bitfield.            */
        LL_ADC_REG_SetSequencerChAdd(hadc->Instance, sConfig->Channel);
 8000530:	6829      	ldr	r1, [r5, #0]
  SET_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
 8000532:	0353      	lsls	r3, r2, #13
 8000534:	6a88      	ldr	r0, [r1, #40]	; 0x28
 8000536:	0b5b      	lsrs	r3, r3, #13
  MODIFY_REG(ADCx->CHSELR,
 8000538:	4303      	orrs	r3, r0
 800053a:	628b      	str	r3, [r1, #40]	; 0x28
          LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
        }
      }
      
      /* Set sampling time of the selected ADC channel */
      LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
 800053c:	6828      	ldr	r0, [r5, #0]
  MODIFY_REG(ADCx->SMPR,
 800053e:	68bb      	ldr	r3, [r7, #8]
 8000540:	496e      	ldr	r1, [pc, #440]	; (80006fc <HAL_ADC_ConfigChannel+0x218>)
 8000542:	6944      	ldr	r4, [r0, #20]
 8000544:	4019      	ands	r1, r3
 8000546:	4061      	eors	r1, r4
 8000548:	0213      	lsls	r3, r2, #8
 800054a:	400b      	ands	r3, r1
 800054c:	4063      	eors	r3, r4
 800054e:	6143      	str	r3, [r0, #20]
      /* internal measurement paths enable: If internal channel selected,     */
      /* enable dedicated internal buffers and path.                          */
      /* Note: these internal measurement paths can be disabled using         */
      /*       HAL_ADC_DeInit() or removing the channel from sequencer with   */
      /*       channel configuration parameter "Rank".                        */
      if(__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 8000550:	2a00      	cmp	r2, #0
 8000552:	db65      	blt.n	8000620 <HAL_ADC_ConfigChannel+0x13c>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8000554:	2400      	movs	r4, #0
 8000556:	e091      	b.n	800067c <HAL_ADC_ConfigChannel+0x198>
        MODIFY_REG(hadc->ADCGroupRegularSequencerRanks,
 8000558:	211f      	movs	r1, #31
 800055a:	9b01      	ldr	r3, [sp, #4]
 800055c:	400b      	ands	r3, r1
 800055e:	9302      	str	r3, [sp, #8]
 8000560:	230f      	movs	r3, #15
 8000562:	9802      	ldr	r0, [sp, #8]
 8000564:	4083      	lsls	r3, r0
 8000566:	43db      	mvns	r3, r3
 8000568:	9304      	str	r3, [sp, #16]
 800056a:	9804      	ldr	r0, [sp, #16]
 800056c:	6e2b      	ldr	r3, [r5, #96]	; 0x60
 800056e:	4003      	ands	r3, r0
 8000570:	9305      	str	r3, [sp, #20]
 8000572:	0350      	lsls	r0, r2, #13
 8000574:	0013      	movs	r3, r2
 8000576:	2800      	cmp	r0, #0
 8000578:	d115      	bne.n	80005a6 <HAL_ADC_ConfigChannel+0xc2>
 800057a:	0e90      	lsrs	r0, r2, #26
 800057c:	4008      	ands	r0, r1
 800057e:	9902      	ldr	r1, [sp, #8]
 8000580:	4088      	lsls	r0, r1
 8000582:	9905      	ldr	r1, [sp, #20]
 8000584:	4308      	orrs	r0, r1
        if(((sConfig->Rank >> 2UL) + 1UL) <= hadc->Init.NbrOfConversion)
 8000586:	9901      	ldr	r1, [sp, #4]
        MODIFY_REG(hadc->ADCGroupRegularSequencerRanks,
 8000588:	6628      	str	r0, [r5, #96]	; 0x60
        if(((sConfig->Rank >> 2UL) + 1UL) <= hadc->Init.NbrOfConversion)
 800058a:	0889      	lsrs	r1, r1, #2
 800058c:	69e8      	ldr	r0, [r5, #28]
 800058e:	3101      	adds	r1, #1
 8000590:	4281      	cmp	r1, r0
 8000592:	d8d3      	bhi.n	800053c <HAL_ADC_ConfigChannel+0x58>
  MODIFY_REG(ADCx->CHSELR,
 8000594:	9c02      	ldr	r4, [sp, #8]
          LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 8000596:	6829      	ldr	r1, [r5, #0]
 8000598:	009b      	lsls	r3, r3, #2
 800059a:	0f1b      	lsrs	r3, r3, #28
 800059c:	6a88      	ldr	r0, [r1, #40]	; 0x28
 800059e:	40a3      	lsls	r3, r4
 80005a0:	9c04      	ldr	r4, [sp, #16]
 80005a2:	4020      	ands	r0, r4
 80005a4:	e7c8      	b.n	8000538 <HAL_ADC_ConfigChannel+0x54>
        MODIFY_REG(hadc->ADCGroupRegularSequencerRanks,
 80005a6:	9803      	ldr	r0, [sp, #12]
 80005a8:	4232      	tst	r2, r6
 80005aa:	d1e8      	bne.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 80005ac:	0030      	movs	r0, r6
 80005ae:	4222      	tst	r2, r4
 80005b0:	d1e5      	bne.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 80005b2:	4661      	mov	r1, ip
 80005b4:	0020      	movs	r0, r4
 80005b6:	420a      	tst	r2, r1
 80005b8:	d1e1      	bne.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 80005ba:	2003      	movs	r0, #3
 80005bc:	0711      	lsls	r1, r2, #28
 80005be:	d4de      	bmi.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 80005c0:	4660      	mov	r0, ip
 80005c2:	06d1      	lsls	r1, r2, #27
 80005c4:	d4db      	bmi.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 80005c6:	2005      	movs	r0, #5
 80005c8:	0691      	lsls	r1, r2, #26
 80005ca:	d4d8      	bmi.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 80005cc:	3001      	adds	r0, #1
 80005ce:	0651      	lsls	r1, r2, #25
 80005d0:	d4d5      	bmi.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 80005d2:	3001      	adds	r0, #1
 80005d4:	0611      	lsls	r1, r2, #24
 80005d6:	d4d2      	bmi.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 80005d8:	3001      	adds	r0, #1
 80005da:	05d1      	lsls	r1, r2, #23
 80005dc:	d4cf      	bmi.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 80005de:	3001      	adds	r0, #1
 80005e0:	0591      	lsls	r1, r2, #22
 80005e2:	d4cc      	bmi.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 80005e4:	3001      	adds	r0, #1
 80005e6:	0551      	lsls	r1, r2, #21
 80005e8:	d4c9      	bmi.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 80005ea:	3001      	adds	r0, #1
 80005ec:	0511      	lsls	r1, r2, #20
 80005ee:	d4c6      	bmi.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 80005f0:	3001      	adds	r0, #1
 80005f2:	04d1      	lsls	r1, r2, #19
 80005f4:	d4c3      	bmi.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 80005f6:	3001      	adds	r0, #1
 80005f8:	0491      	lsls	r1, r2, #18
 80005fa:	d4c0      	bmi.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 80005fc:	3001      	adds	r0, #1
 80005fe:	0451      	lsls	r1, r2, #17
 8000600:	d4bd      	bmi.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 8000602:	3001      	adds	r0, #1
 8000604:	0411      	lsls	r1, r2, #16
 8000606:	d4ba      	bmi.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 8000608:	3001      	adds	r0, #1
 800060a:	03d1      	lsls	r1, r2, #15
 800060c:	d4b7      	bmi.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 800060e:	3001      	adds	r0, #1
 8000610:	0391      	lsls	r1, r2, #14
 8000612:	d4b4      	bmi.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 8000614:	2080      	movs	r0, #128	; 0x80
 8000616:	02c0      	lsls	r0, r0, #11
 8000618:	4010      	ands	r0, r2
 800061a:	d0b0      	beq.n	800057e <HAL_ADC_ConfigChannel+0x9a>
 800061c:	2012      	movs	r0, #18
 800061e:	e7ae      	b.n	800057e <HAL_ADC_ConfigChannel+0x9a>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8000620:	21e0      	movs	r1, #224	; 0xe0
 8000622:	4b37      	ldr	r3, [pc, #220]	; (8000700 <HAL_ADC_ConfigChannel+0x21c>)
      {
        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
        
        /* If the requested internal measurement path has already been enabled,   */
        /* bypass the configuration processing.                                   */
        if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 8000624:	4837      	ldr	r0, [pc, #220]	; (8000704 <HAL_ADC_ConfigChannel+0x220>)
 8000626:	681c      	ldr	r4, [r3, #0]
 8000628:	0449      	lsls	r1, r1, #17
 800062a:	4021      	ands	r1, r4
 800062c:	4282      	cmp	r2, r0
 800062e:	d117      	bne.n	8000660 <HAL_ADC_ConfigChannel+0x17c>
 8000630:	2080      	movs	r0, #128	; 0x80
 8000632:	0400      	lsls	r0, r0, #16
 8000634:	4204      	tst	r4, r0
 8000636:	d18d      	bne.n	8000554 <HAL_ADC_ConfigChannel+0x70>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 8000638:	681a      	ldr	r2, [r3, #0]
 800063a:	4c33      	ldr	r4, [pc, #204]	; (8000708 <HAL_ADC_ConfigChannel+0x224>)
 800063c:	4022      	ands	r2, r4
 800063e:	430a      	orrs	r2, r1
 8000640:	4302      	orrs	r2, r0
 8000642:	601a      	str	r2, [r3, #0]
          /* Delay for temperature sensor stabilization time */
          /* Wait loop initialization and execution */
          /* Note: Variable divided by 2 to compensate partially              */
          /*       CPU processing cycles, scaling in us split to not          */
          /*       exceed 32 bits register capacity and handle low frequency. */
          wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 8000644:	4b31      	ldr	r3, [pc, #196]	; (800070c <HAL_ADC_ConfigChannel+0x228>)
 8000646:	4932      	ldr	r1, [pc, #200]	; (8000710 <HAL_ADC_ConfigChannel+0x22c>)
 8000648:	6818      	ldr	r0, [r3, #0]
 800064a:	f7ff fd5d 	bl	8000108 <__udivsi3>
 800064e:	9007      	str	r0, [sp, #28]
          while(wait_loop_index != 0UL)
 8000650:	9b07      	ldr	r3, [sp, #28]
 8000652:	2b00      	cmp	r3, #0
 8000654:	d100      	bne.n	8000658 <HAL_ADC_ConfigChannel+0x174>
 8000656:	e77d      	b.n	8000554 <HAL_ADC_ConfigChannel+0x70>
          {
            wait_loop_index--;
 8000658:	9b07      	ldr	r3, [sp, #28]
 800065a:	3b01      	subs	r3, #1
 800065c:	9307      	str	r3, [sp, #28]
 800065e:	e7f7      	b.n	8000650 <HAL_ADC_ConfigChannel+0x16c>
          }
        }
        else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8000660:	482c      	ldr	r0, [pc, #176]	; (8000714 <HAL_ADC_ConfigChannel+0x230>)
 8000662:	4282      	cmp	r2, r0
 8000664:	d110      	bne.n	8000688 <HAL_ADC_ConfigChannel+0x1a4>
 8000666:	2080      	movs	r0, #128	; 0x80
 8000668:	0440      	lsls	r0, r0, #17
        {
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
        }
        else if ((sConfig->Channel == ADC_CHANNEL_VREFINT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 800066a:	4004      	ands	r4, r0
 800066c:	d000      	beq.n	8000670 <HAL_ADC_ConfigChannel+0x18c>
 800066e:	e771      	b.n	8000554 <HAL_ADC_ConfigChannel+0x70>
 8000670:	681a      	ldr	r2, [r3, #0]
 8000672:	4e25      	ldr	r6, [pc, #148]	; (8000708 <HAL_ADC_ConfigChannel+0x224>)
 8000674:	4032      	ands	r2, r6
 8000676:	430a      	orrs	r2, r1
 8000678:	4302      	orrs	r2, r0
 800067a:	601a      	str	r2, [r3, #0]
    
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 800067c:	2300      	movs	r3, #0
 800067e:	3554      	adds	r5, #84	; 0x54
 8000680:	702b      	strb	r3, [r5, #0]
  
  /* Return function status */
  return tmp_hal_status;
}
 8000682:	0020      	movs	r0, r4
 8000684:	b009      	add	sp, #36	; 0x24
 8000686:	bdf0      	pop	{r4, r5, r6, r7, pc}
        else if ((sConfig->Channel == ADC_CHANNEL_VREFINT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 8000688:	4823      	ldr	r0, [pc, #140]	; (8000718 <HAL_ADC_ConfigChannel+0x234>)
 800068a:	4282      	cmp	r2, r0
 800068c:	d000      	beq.n	8000690 <HAL_ADC_ConfigChannel+0x1ac>
 800068e:	e761      	b.n	8000554 <HAL_ADC_ConfigChannel+0x70>
 8000690:	2080      	movs	r0, #128	; 0x80
 8000692:	03c0      	lsls	r0, r0, #15
 8000694:	e7e9      	b.n	800066a <HAL_ADC_ConfigChannel+0x186>
      if((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)         ||
 8000696:	4660      	mov	r0, ip
 8000698:	4383      	bics	r3, r0
 800069a:	428b      	cmp	r3, r1
 800069c:	d105      	bne.n	80006aa <HAL_ADC_ConfigChannel+0x1c6>
        LL_ADC_REG_SetSequencerChRem(hadc->Instance, sConfig->Channel);
 800069e:	6828      	ldr	r0, [r5, #0]
  CLEAR_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
 80006a0:	0351      	lsls	r1, r2, #13
 80006a2:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80006a4:	0b49      	lsrs	r1, r1, #13
 80006a6:	438b      	bics	r3, r1
 80006a8:	6283      	str	r3, [r0, #40]	; 0x28
      if(__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 80006aa:	2a00      	cmp	r2, #0
 80006ac:	db00      	blt.n	80006b0 <HAL_ADC_ConfigChannel+0x1cc>
 80006ae:	e751      	b.n	8000554 <HAL_ADC_ConfigChannel+0x70>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80006b0:	4b13      	ldr	r3, [pc, #76]	; (8000700 <HAL_ADC_ConfigChannel+0x21c>)
        if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 80006b2:	4914      	ldr	r1, [pc, #80]	; (8000704 <HAL_ADC_ConfigChannel+0x220>)
 80006b4:	6818      	ldr	r0, [r3, #0]
 80006b6:	428a      	cmp	r2, r1
 80006b8:	d108      	bne.n	80006cc <HAL_ADC_ConfigChannel+0x1e8>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), ~LL_ADC_PATH_INTERNAL_TEMPSENSOR & tmp_config_internal_channel);
 80006ba:	22a0      	movs	r2, #160	; 0xa0
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 80006bc:	681c      	ldr	r4, [r3, #0]
 80006be:	0452      	lsls	r2, r2, #17
 80006c0:	4911      	ldr	r1, [pc, #68]	; (8000708 <HAL_ADC_ConfigChannel+0x224>)
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), ~LL_ADC_PATH_INTERNAL_VBAT & tmp_config_internal_channel);
 80006c2:	4002      	ands	r2, r0
 80006c4:	4021      	ands	r1, r4
 80006c6:	430a      	orrs	r2, r1
 80006c8:	601a      	str	r2, [r3, #0]
 80006ca:	e743      	b.n	8000554 <HAL_ADC_ConfigChannel+0x70>
        else if (sConfig->Channel == ADC_CHANNEL_VBAT)
 80006cc:	4911      	ldr	r1, [pc, #68]	; (8000714 <HAL_ADC_ConfigChannel+0x230>)
 80006ce:	428a      	cmp	r2, r1
 80006d0:	d103      	bne.n	80006da <HAL_ADC_ConfigChannel+0x1f6>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), ~LL_ADC_PATH_INTERNAL_VBAT & tmp_config_internal_channel);
 80006d2:	22c0      	movs	r2, #192	; 0xc0
 80006d4:	681c      	ldr	r4, [r3, #0]
 80006d6:	0412      	lsls	r2, r2, #16
 80006d8:	e7f2      	b.n	80006c0 <HAL_ADC_ConfigChannel+0x1dc>
        else if (sConfig->Channel == ADC_CHANNEL_VREFINT)
 80006da:	490f      	ldr	r1, [pc, #60]	; (8000718 <HAL_ADC_ConfigChannel+0x234>)
 80006dc:	428a      	cmp	r2, r1
 80006de:	d000      	beq.n	80006e2 <HAL_ADC_ConfigChannel+0x1fe>
 80006e0:	e738      	b.n	8000554 <HAL_ADC_ConfigChannel+0x70>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), ~LL_ADC_PATH_INTERNAL_VREFINT & tmp_config_internal_channel);
 80006e2:	22c0      	movs	r2, #192	; 0xc0
 80006e4:	0452      	lsls	r2, r2, #17
 80006e6:	6819      	ldr	r1, [r3, #0]
 80006e8:	4002      	ands	r2, r0
 80006ea:	4807      	ldr	r0, [pc, #28]	; (8000708 <HAL_ADC_ConfigChannel+0x224>)
 80006ec:	4001      	ands	r1, r0
 80006ee:	e7ea      	b.n	80006c6 <HAL_ADC_ConfigChannel+0x1e2>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80006f0:	2320      	movs	r3, #32
 80006f2:	6daa      	ldr	r2, [r5, #88]	; 0x58
    tmp_hal_status = HAL_ERROR;
 80006f4:	0034      	movs	r4, r6
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80006f6:	4313      	orrs	r3, r2
 80006f8:	65ab      	str	r3, [r5, #88]	; 0x58
 80006fa:	e7bf      	b.n	800067c <HAL_ADC_ConfigChannel+0x198>
 80006fc:	07ffff00 	.word	0x07ffff00
 8000700:	40012708 	.word	0x40012708
 8000704:	b0001000 	.word	0xb0001000
 8000708:	fe3fffff 	.word	0xfe3fffff
 800070c:	20000008 	.word	0x20000008
 8000710:	00030d40 	.word	0x00030d40
 8000714:	b8004000 	.word	0xb8004000
 8000718:	b4002000 	.word	0xb4002000

0800071c <HAL_NVIC_SetPriority>:
  *         with stm32g0xx devices, this parameter is a dummy value and it is ignored, because
  *         no subpriority supported in Cortex M0+ based products.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800071c:	b570      	push	{r4, r5, r6, lr}
 800071e:	0189      	lsls	r1, r1, #6
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8000720:	2800      	cmp	r0, #0
 8000722:	da14      	bge.n	800074e <HAL_NVIC_SetPriority+0x32>
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8000724:	230f      	movs	r3, #15
 8000726:	b2c0      	uxtb	r0, r0
 8000728:	4003      	ands	r3, r0
 800072a:	3b08      	subs	r3, #8
 800072c:	4a11      	ldr	r2, [pc, #68]	; (8000774 <HAL_NVIC_SetPriority+0x58>)
 800072e:	089b      	lsrs	r3, r3, #2
 8000730:	009b      	lsls	r3, r3, #2
 8000732:	189b      	adds	r3, r3, r2
 8000734:	2203      	movs	r2, #3
 8000736:	4010      	ands	r0, r2
 8000738:	4090      	lsls	r0, r2
 800073a:	32fc      	adds	r2, #252	; 0xfc
 800073c:	0015      	movs	r5, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 800073e:	4011      	ands	r1, r2
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8000740:	4085      	lsls	r5, r0
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8000742:	4081      	lsls	r1, r0
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8000744:	69dc      	ldr	r4, [r3, #28]
 8000746:	43ac      	bics	r4, r5
 8000748:	4321      	orrs	r1, r4
 800074a:	61d9      	str	r1, [r3, #28]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
}
 800074c:	bd70      	pop	{r4, r5, r6, pc}
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800074e:	2503      	movs	r5, #3
 8000750:	0883      	lsrs	r3, r0, #2
 8000752:	4028      	ands	r0, r5
 8000754:	40a8      	lsls	r0, r5
 8000756:	35fc      	adds	r5, #252	; 0xfc
 8000758:	002e      	movs	r6, r5
 800075a:	4a07      	ldr	r2, [pc, #28]	; (8000778 <HAL_NVIC_SetPriority+0x5c>)
 800075c:	009b      	lsls	r3, r3, #2
 800075e:	189b      	adds	r3, r3, r2
 8000760:	22c0      	movs	r2, #192	; 0xc0
 8000762:	4086      	lsls	r6, r0
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8000764:	4029      	ands	r1, r5
 8000766:	4081      	lsls	r1, r0
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8000768:	0092      	lsls	r2, r2, #2
 800076a:	589c      	ldr	r4, [r3, r2]
 800076c:	43b4      	bics	r4, r6
 800076e:	4321      	orrs	r1, r4
 8000770:	5099      	str	r1, [r3, r2]
 8000772:	e7eb      	b.n	800074c <HAL_NVIC_SetPriority+0x30>
 8000774:	e000ed00 	.word	0xe000ed00
 8000778:	e000e100 	.word	0xe000e100

0800077c <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800077c:	231f      	movs	r3, #31
 800077e:	4018      	ands	r0, r3
 8000780:	3b1e      	subs	r3, #30
 8000782:	4083      	lsls	r3, r0
 8000784:	4a01      	ldr	r2, [pc, #4]	; (800078c <HAL_NVIC_EnableIRQ+0x10>)
 8000786:	6013      	str	r3, [r2, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8000788:	4770      	bx	lr
 800078a:	46c0      	nop			; (mov r8, r8)
 800078c:	e000e100 	.word	0xe000e100

08000790 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000790:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8000792:	680b      	ldr	r3, [r1, #0]
{
 8000794:	b085      	sub	sp, #20
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8000796:	9302      	str	r3, [sp, #8]
  uint32_t position = 0x00u;
 8000798:	2300      	movs	r3, #0
{
 800079a:	9101      	str	r1, [sp, #4]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800079c:	9a02      	ldr	r2, [sp, #8]
 800079e:	40da      	lsrs	r2, r3
 80007a0:	d101      	bne.n	80007a6 <HAL_GPIO_Init+0x16>
      }
    }

    position++;
  }
}
 80007a2:	b005      	add	sp, #20
 80007a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 80007a6:	2201      	movs	r2, #1
 80007a8:	409a      	lsls	r2, r3
 80007aa:	9203      	str	r2, [sp, #12]
 80007ac:	9903      	ldr	r1, [sp, #12]
 80007ae:	9a02      	ldr	r2, [sp, #8]
 80007b0:	400a      	ands	r2, r1
 80007b2:	9200      	str	r2, [sp, #0]
    if (iocurrent != 0x00u)
 80007b4:	d100      	bne.n	80007b8 <HAL_GPIO_Init+0x28>
 80007b6:	e085      	b.n	80008c4 <HAL_GPIO_Init+0x134>
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 80007b8:	9a01      	ldr	r2, [sp, #4]
 80007ba:	2110      	movs	r1, #16
 80007bc:	6852      	ldr	r2, [r2, #4]
 80007be:	0016      	movs	r6, r2
 80007c0:	438e      	bics	r6, r1
 80007c2:	2e02      	cmp	r6, #2
 80007c4:	d10e      	bne.n	80007e4 <HAL_GPIO_Init+0x54>
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 80007c6:	2507      	movs	r5, #7
 80007c8:	401d      	ands	r5, r3
 80007ca:	00ad      	lsls	r5, r5, #2
 80007cc:	3901      	subs	r1, #1
 80007ce:	40a9      	lsls	r1, r5
        temp = GPIOx->AFR[position >> 3u];
 80007d0:	08dc      	lsrs	r4, r3, #3
 80007d2:	00a4      	lsls	r4, r4, #2
 80007d4:	1904      	adds	r4, r0, r4
 80007d6:	6a27      	ldr	r7, [r4, #32]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 80007d8:	438f      	bics	r7, r1
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 80007da:	9901      	ldr	r1, [sp, #4]
 80007dc:	6909      	ldr	r1, [r1, #16]
 80007de:	40a9      	lsls	r1, r5
 80007e0:	430f      	orrs	r7, r1
        GPIOx->AFR[position >> 3u] = temp;
 80007e2:	6227      	str	r7, [r4, #32]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 80007e4:	2403      	movs	r4, #3
 80007e6:	005f      	lsls	r7, r3, #1
 80007e8:	40bc      	lsls	r4, r7
 80007ea:	43e4      	mvns	r4, r4
      temp = GPIOx->MODER;
 80007ec:	6805      	ldr	r5, [r0, #0]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80007ee:	3e01      	subs	r6, #1
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 80007f0:	4025      	ands	r5, r4
 80007f2:	46ac      	mov	ip, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 80007f4:	2503      	movs	r5, #3
 80007f6:	4015      	ands	r5, r2
 80007f8:	40bd      	lsls	r5, r7
 80007fa:	4661      	mov	r1, ip
 80007fc:	430d      	orrs	r5, r1
      GPIOx->MODER = temp;
 80007fe:	6005      	str	r5, [r0, #0]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000800:	2e01      	cmp	r6, #1
 8000802:	d80f      	bhi.n	8000824 <HAL_GPIO_Init+0x94>
        temp |= (GPIO_Init->Speed << (position * 2u));
 8000804:	9901      	ldr	r1, [sp, #4]
        temp = GPIOx->OSPEEDR;
 8000806:	6886      	ldr	r6, [r0, #8]
        temp |= (GPIO_Init->Speed << (position * 2u));
 8000808:	68cd      	ldr	r5, [r1, #12]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 800080a:	4026      	ands	r6, r4
        temp |= (GPIO_Init->Speed << (position * 2u));
 800080c:	40bd      	lsls	r5, r7
 800080e:	4335      	orrs	r5, r6
        GPIOx->OSPEEDR = temp;
 8000810:	6085      	str	r5, [r0, #8]
        temp = GPIOx->OTYPER;
 8000812:	6846      	ldr	r6, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8000814:	9903      	ldr	r1, [sp, #12]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 8000816:	0915      	lsrs	r5, r2, #4
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8000818:	438e      	bics	r6, r1
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 800081a:	2101      	movs	r1, #1
 800081c:	400d      	ands	r5, r1
 800081e:	409d      	lsls	r5, r3
 8000820:	4335      	orrs	r5, r6
        GPIOx->OTYPER = temp;
 8000822:	6045      	str	r5, [r0, #4]
      temp = GPIOx->PUPDR;
 8000824:	68c5      	ldr	r5, [r0, #12]
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 8000826:	9901      	ldr	r1, [sp, #4]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
 8000828:	402c      	ands	r4, r5
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 800082a:	688d      	ldr	r5, [r1, #8]
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800082c:	2180      	movs	r1, #128	; 0x80
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 800082e:	40bd      	lsls	r5, r7
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000830:	0549      	lsls	r1, r1, #21
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 8000832:	432c      	orrs	r4, r5
      GPIOx->PUPDR = temp;
 8000834:	60c4      	str	r4, [r0, #12]
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000836:	420a      	tst	r2, r1
 8000838:	d044      	beq.n	80008c4 <HAL_GPIO_Init+0x134>
        temp &= ~(0x0FuL << (8u * (position & 0x03u)));
 800083a:	2603      	movs	r6, #3
 800083c:	240f      	movs	r4, #15
 800083e:	4922      	ldr	r1, [pc, #136]	; (80008c8 <HAL_GPIO_Init+0x138>)
        temp = EXTI->EXTICR[position >> 2u];
 8000840:	089d      	lsrs	r5, r3, #2
        temp &= ~(0x0FuL << (8u * (position & 0x03u)));
 8000842:	401e      	ands	r6, r3
 8000844:	00ad      	lsls	r5, r5, #2
 8000846:	00f6      	lsls	r6, r6, #3
 8000848:	186d      	adds	r5, r5, r1
 800084a:	40b4      	lsls	r4, r6
        temp |= (GPIO_GET_INDEX(GPIOx) << (8u * (position & 0x03u)));
 800084c:	21a0      	movs	r1, #160	; 0xa0
        temp = EXTI->EXTICR[position >> 2u];
 800084e:	6e2f      	ldr	r7, [r5, #96]	; 0x60
        temp |= (GPIO_GET_INDEX(GPIOx) << (8u * (position & 0x03u)));
 8000850:	05c9      	lsls	r1, r1, #23
        temp &= ~(0x0FuL << (8u * (position & 0x03u)));
 8000852:	43a7      	bics	r7, r4
        temp |= (GPIO_GET_INDEX(GPIOx) << (8u * (position & 0x03u)));
 8000854:	2400      	movs	r4, #0
 8000856:	4288      	cmp	r0, r1
 8000858:	d00c      	beq.n	8000874 <HAL_GPIO_Init+0xe4>
 800085a:	491c      	ldr	r1, [pc, #112]	; (80008cc <HAL_GPIO_Init+0x13c>)
 800085c:	3401      	adds	r4, #1
 800085e:	4288      	cmp	r0, r1
 8000860:	d008      	beq.n	8000874 <HAL_GPIO_Init+0xe4>
 8000862:	491b      	ldr	r1, [pc, #108]	; (80008d0 <HAL_GPIO_Init+0x140>)
 8000864:	3401      	adds	r4, #1
 8000866:	4288      	cmp	r0, r1
 8000868:	d004      	beq.n	8000874 <HAL_GPIO_Init+0xe4>
 800086a:	491a      	ldr	r1, [pc, #104]	; (80008d4 <HAL_GPIO_Init+0x144>)
 800086c:	3403      	adds	r4, #3
 800086e:	4288      	cmp	r0, r1
 8000870:	d100      	bne.n	8000874 <HAL_GPIO_Init+0xe4>
 8000872:	3c02      	subs	r4, #2
 8000874:	40b4      	lsls	r4, r6
        temp &= ~(iocurrent);
 8000876:	9900      	ldr	r1, [sp, #0]
        temp |= (GPIO_GET_INDEX(GPIOx) << (8u * (position & 0x03u)));
 8000878:	433c      	orrs	r4, r7
          temp |= iocurrent;
 800087a:	000e      	movs	r6, r1
        EXTI->EXTICR[position >> 2u] = temp;
 800087c:	662c      	str	r4, [r5, #96]	; 0x60
        temp = EXTI->IMR1;
 800087e:	4c16      	ldr	r4, [pc, #88]	; (80008d8 <HAL_GPIO_Init+0x148>)
        temp &= ~(iocurrent);
 8000880:	43cd      	mvns	r5, r1
        temp = EXTI->IMR1;
 8000882:	6fe7      	ldr	r7, [r4, #124]	; 0x7c
          temp |= iocurrent;
 8000884:	433e      	orrs	r6, r7
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8000886:	03d1      	lsls	r1, r2, #15
 8000888:	d401      	bmi.n	800088e <HAL_GPIO_Init+0xfe>
        temp &= ~(iocurrent);
 800088a:	003e      	movs	r6, r7
 800088c:	402e      	ands	r6, r5
        EXTI->IMR1 = temp;
 800088e:	67e6      	str	r6, [r4, #124]	; 0x7c
        temp = EXTI->EMR1;
 8000890:	4e12      	ldr	r6, [pc, #72]	; (80008dc <HAL_GPIO_Init+0x14c>)
          temp |= iocurrent;
 8000892:	9f00      	ldr	r7, [sp, #0]
        temp = EXTI->EMR1;
 8000894:	6ff4      	ldr	r4, [r6, #124]	; 0x7c
          temp |= iocurrent;
 8000896:	4327      	orrs	r7, r4
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000898:	0391      	lsls	r1, r2, #14
 800089a:	d401      	bmi.n	80008a0 <HAL_GPIO_Init+0x110>
        temp &= ~(iocurrent);
 800089c:	402c      	ands	r4, r5
 800089e:	0027      	movs	r7, r4
        EXTI->EMR1 = temp;
 80008a0:	4c09      	ldr	r4, [pc, #36]	; (80008c8 <HAL_GPIO_Init+0x138>)
 80008a2:	67f7      	str	r7, [r6, #124]	; 0x7c
        temp = EXTI->RTSR1;
 80008a4:	6827      	ldr	r7, [r4, #0]
          temp |= iocurrent;
 80008a6:	9e00      	ldr	r6, [sp, #0]
 80008a8:	433e      	orrs	r6, r7
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80008aa:	02d1      	lsls	r1, r2, #11
 80008ac:	d401      	bmi.n	80008b2 <HAL_GPIO_Init+0x122>
        temp &= ~(iocurrent);
 80008ae:	003e      	movs	r6, r7
 80008b0:	402e      	ands	r6, r5
        EXTI->RTSR1 = temp;
 80008b2:	6026      	str	r6, [r4, #0]
        temp = EXTI->FTSR1;
 80008b4:	6866      	ldr	r6, [r4, #4]
          temp |= iocurrent;
 80008b6:	9f00      	ldr	r7, [sp, #0]
 80008b8:	4337      	orrs	r7, r6
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80008ba:	0292      	lsls	r2, r2, #10
 80008bc:	d401      	bmi.n	80008c2 <HAL_GPIO_Init+0x132>
        temp &= ~(iocurrent);
 80008be:	402e      	ands	r6, r5
 80008c0:	0037      	movs	r7, r6
        EXTI->FTSR1 = temp;
 80008c2:	6067      	str	r7, [r4, #4]
    position++;
 80008c4:	3301      	adds	r3, #1
 80008c6:	e769      	b.n	800079c <HAL_GPIO_Init+0xc>
 80008c8:	40021800 	.word	0x40021800
 80008cc:	50000400 	.word	0x50000400
 80008d0:	50000800 	.word	0x50000800
 80008d4:	50000c00 	.word	0x50000c00
 80008d8:	40021804 	.word	0x40021804
 80008dc:	40021808 	.word	0x40021808

080008e0 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 80008e0:	2a00      	cmp	r2, #0
 80008e2:	d001      	beq.n	80008e8 <HAL_GPIO_WritePin+0x8>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 80008e4:	6181      	str	r1, [r0, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 80008e6:	4770      	bx	lr
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 80008e8:	6281      	str	r1, [r0, #40]	; 0x28
}
 80008ea:	e7fc      	b.n	80008e6 <HAL_GPIO_WritePin+0x6>

080008ec <HAL_PWREx_ControlVoltageScaling>:
  *        cleared before returning the status. If the flag is not cleared within
  *        6 microseconds, HAL_TIMEOUT status is reported.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
 80008ec:	b510      	push	{r4, lr}
  uint32_t wait_loop_index;

  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));

  /* Modify voltage scaling range */
  MODIFY_REG(PWR->CR1, PWR_CR1_VOS, VoltageScaling);
 80008ee:	4c10      	ldr	r4, [pc, #64]	; (8000930 <HAL_PWREx_ControlVoltageScaling+0x44>)
 80008f0:	4910      	ldr	r1, [pc, #64]	; (8000934 <HAL_PWREx_ControlVoltageScaling+0x48>)
 80008f2:	6823      	ldr	r3, [r4, #0]
{
 80008f4:	0002      	movs	r2, r0
  MODIFY_REG(PWR->CR1, PWR_CR1_VOS, VoltageScaling);
 80008f6:	400b      	ands	r3, r1
 80008f8:	4303      	orrs	r3, r0
 80008fa:	6023      	str	r3, [r4, #0]

  /* In case of Range 1 selected, we need to ensure that main regulator reaches new value */
  if(VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 80008fc:	2380      	movs	r3, #128	; 0x80
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
 80008fe:	2000      	movs	r0, #0
  if(VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 8000900:	009b      	lsls	r3, r3, #2
 8000902:	429a      	cmp	r2, r3
 8000904:	d10c      	bne.n	8000920 <HAL_PWREx_ControlVoltageScaling+0x34>
    wait_loop_index = ((PWR_VOSF_SETTING_DELAY_6_US * SystemCoreClock ) / 1000000U) + 1U;
 8000906:	4b0c      	ldr	r3, [pc, #48]	; (8000938 <HAL_PWREx_ControlVoltageScaling+0x4c>)
 8000908:	490c      	ldr	r1, [pc, #48]	; (800093c <HAL_PWREx_ControlVoltageScaling+0x50>)
 800090a:	6818      	ldr	r0, [r3, #0]
 800090c:	2306      	movs	r3, #6
 800090e:	4358      	muls	r0, r3
 8000910:	f7ff fbfa 	bl	8000108 <__udivsi3>
    while(HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 8000914:	2280      	movs	r2, #128	; 0x80
    wait_loop_index = ((PWR_VOSF_SETTING_DELAY_6_US * SystemCoreClock ) / 1000000U) + 1U;
 8000916:	1c43      	adds	r3, r0, #1
    while(HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 8000918:	00d2      	lsls	r2, r2, #3
 800091a:	6960      	ldr	r0, [r4, #20]
 800091c:	4010      	ands	r0, r2
 800091e:	d100      	bne.n	8000922 <HAL_PWREx_ControlVoltageScaling+0x36>
}
 8000920:	bd10      	pop	{r4, pc}
      if(wait_loop_index != 0U)
 8000922:	2b00      	cmp	r3, #0
 8000924:	d001      	beq.n	800092a <HAL_PWREx_ControlVoltageScaling+0x3e>
        wait_loop_index--;
 8000926:	3b01      	subs	r3, #1
 8000928:	e7f7      	b.n	800091a <HAL_PWREx_ControlVoltageScaling+0x2e>
        return HAL_TIMEOUT;
 800092a:	2003      	movs	r0, #3
 800092c:	e7f8      	b.n	8000920 <HAL_PWREx_ControlVoltageScaling+0x34>
 800092e:	46c0      	nop			; (mov r8, r8)
 8000930:	40007000 	.word	0x40007000
 8000934:	fffff9ff 	.word	0xfffff9ff
 8000938:	20000008 	.word	0x20000008
 800093c:	000f4240 	.word	0x000f4240

08000940 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to LSE Off
  *         first and then to LSE On or LSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8000940:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000942:	0004      	movs	r4, r0
 8000944:	b085      	sub	sp, #20
  uint32_t tickstart;
  uint32_t temp_sysclksrc;
  uint32_t temp_pllckcfg;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 8000946:	2800      	cmp	r0, #0
 8000948:	d102      	bne.n	8000950 <HAL_RCC_OscConfig+0x10>
  {
    return HAL_ERROR;
 800094a:	2001      	movs	r0, #1
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 800094c:	b005      	add	sp, #20
 800094e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000950:	6803      	ldr	r3, [r0, #0]
 8000952:	07db      	lsls	r3, r3, #31
 8000954:	d410      	bmi.n	8000978 <HAL_RCC_OscConfig+0x38>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8000956:	6823      	ldr	r3, [r4, #0]
 8000958:	079b      	lsls	r3, r3, #30
 800095a:	d45c      	bmi.n	8000a16 <HAL_RCC_OscConfig+0xd6>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800095c:	6823      	ldr	r3, [r4, #0]
 800095e:	071b      	lsls	r3, r3, #28
 8000960:	d500      	bpl.n	8000964 <HAL_RCC_OscConfig+0x24>
 8000962:	e0c1      	b.n	8000ae8 <HAL_RCC_OscConfig+0x1a8>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8000964:	6823      	ldr	r3, [r4, #0]
 8000966:	075b      	lsls	r3, r3, #29
 8000968:	d500      	bpl.n	800096c <HAL_RCC_OscConfig+0x2c>
 800096a:	e0f3      	b.n	8000b54 <HAL_RCC_OscConfig+0x214>
  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 800096c:	69e1      	ldr	r1, [r4, #28]
 800096e:	2900      	cmp	r1, #0
 8000970:	d000      	beq.n	8000974 <HAL_RCC_OscConfig+0x34>
 8000972:	e171      	b.n	8000c58 <HAL_RCC_OscConfig+0x318>
  return HAL_OK;
 8000974:	2000      	movs	r0, #0
 8000976:	e7e9      	b.n	800094c <HAL_RCC_OscConfig+0xc>
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8000978:	2238      	movs	r2, #56	; 0x38
 800097a:	4dac      	ldr	r5, [pc, #688]	; (8000c2c <HAL_RCC_OscConfig+0x2ec>)
 800097c:	68ab      	ldr	r3, [r5, #8]
 800097e:	4013      	ands	r3, r2
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 8000980:	68ea      	ldr	r2, [r5, #12]
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSE)) || (temp_sysclksrc == RCC_CFGR_SWS_HSE))
 8000982:	2b10      	cmp	r3, #16
 8000984:	d109      	bne.n	800099a <HAL_RCC_OscConfig+0x5a>
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 8000986:	43d2      	mvns	r2, r2
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSE)) || (temp_sysclksrc == RCC_CFGR_SWS_HSE))
 8000988:	0793      	lsls	r3, r2, #30
 800098a:	d108      	bne.n	800099e <HAL_RCC_OscConfig+0x5e>
      if ((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800098c:	682b      	ldr	r3, [r5, #0]
 800098e:	039b      	lsls	r3, r3, #14
 8000990:	d5e1      	bpl.n	8000956 <HAL_RCC_OscConfig+0x16>
 8000992:	6863      	ldr	r3, [r4, #4]
 8000994:	2b00      	cmp	r3, #0
 8000996:	d1de      	bne.n	8000956 <HAL_RCC_OscConfig+0x16>
 8000998:	e7d7      	b.n	800094a <HAL_RCC_OscConfig+0xa>
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSE)) || (temp_sysclksrc == RCC_CFGR_SWS_HSE))
 800099a:	2b08      	cmp	r3, #8
 800099c:	d0f6      	beq.n	800098c <HAL_RCC_OscConfig+0x4c>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800099e:	2280      	movs	r2, #128	; 0x80
 80009a0:	6863      	ldr	r3, [r4, #4]
 80009a2:	0252      	lsls	r2, r2, #9
 80009a4:	4293      	cmp	r3, r2
 80009a6:	d111      	bne.n	80009cc <HAL_RCC_OscConfig+0x8c>
 80009a8:	682a      	ldr	r2, [r5, #0]
 80009aa:	4313      	orrs	r3, r2
 80009ac:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 80009ae:	f7ff fc57 	bl	8000260 <HAL_GetTick>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 80009b2:	2680      	movs	r6, #128	; 0x80
        tickstart = HAL_GetTick();
 80009b4:	0007      	movs	r7, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 80009b6:	02b6      	lsls	r6, r6, #10
 80009b8:	682b      	ldr	r3, [r5, #0]
 80009ba:	4233      	tst	r3, r6
 80009bc:	d1cb      	bne.n	8000956 <HAL_RCC_OscConfig+0x16>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80009be:	f7ff fc4f 	bl	8000260 <HAL_GetTick>
 80009c2:	1bc0      	subs	r0, r0, r7
 80009c4:	2864      	cmp	r0, #100	; 0x64
 80009c6:	d9f7      	bls.n	80009b8 <HAL_RCC_OscConfig+0x78>
            return HAL_TIMEOUT;
 80009c8:	2003      	movs	r0, #3
 80009ca:	e7bf      	b.n	800094c <HAL_RCC_OscConfig+0xc>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80009cc:	21a0      	movs	r1, #160	; 0xa0
 80009ce:	02c9      	lsls	r1, r1, #11
 80009d0:	428b      	cmp	r3, r1
 80009d2:	d108      	bne.n	80009e6 <HAL_RCC_OscConfig+0xa6>
 80009d4:	2380      	movs	r3, #128	; 0x80
 80009d6:	6829      	ldr	r1, [r5, #0]
 80009d8:	02db      	lsls	r3, r3, #11
 80009da:	430b      	orrs	r3, r1
 80009dc:	602b      	str	r3, [r5, #0]
 80009de:	682b      	ldr	r3, [r5, #0]
 80009e0:	431a      	orrs	r2, r3
 80009e2:	602a      	str	r2, [r5, #0]
 80009e4:	e7e3      	b.n	80009ae <HAL_RCC_OscConfig+0x6e>
 80009e6:	682a      	ldr	r2, [r5, #0]
 80009e8:	4991      	ldr	r1, [pc, #580]	; (8000c30 <HAL_RCC_OscConfig+0x2f0>)
 80009ea:	400a      	ands	r2, r1
 80009ec:	602a      	str	r2, [r5, #0]
 80009ee:	682a      	ldr	r2, [r5, #0]
 80009f0:	4990      	ldr	r1, [pc, #576]	; (8000c34 <HAL_RCC_OscConfig+0x2f4>)
 80009f2:	400a      	ands	r2, r1
 80009f4:	602a      	str	r2, [r5, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80009f6:	2b00      	cmp	r3, #0
 80009f8:	d1d9      	bne.n	80009ae <HAL_RCC_OscConfig+0x6e>
        tickstart = HAL_GetTick();
 80009fa:	f7ff fc31 	bl	8000260 <HAL_GetTick>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 80009fe:	2680      	movs	r6, #128	; 0x80
        tickstart = HAL_GetTick();
 8000a00:	0007      	movs	r7, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8000a02:	02b6      	lsls	r6, r6, #10
 8000a04:	682b      	ldr	r3, [r5, #0]
 8000a06:	4233      	tst	r3, r6
 8000a08:	d0a5      	beq.n	8000956 <HAL_RCC_OscConfig+0x16>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8000a0a:	f7ff fc29 	bl	8000260 <HAL_GetTick>
 8000a0e:	1bc0      	subs	r0, r0, r7
 8000a10:	2864      	cmp	r0, #100	; 0x64
 8000a12:	d9f7      	bls.n	8000a04 <HAL_RCC_OscConfig+0xc4>
 8000a14:	e7d8      	b.n	80009c8 <HAL_RCC_OscConfig+0x88>
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8000a16:	2338      	movs	r3, #56	; 0x38
 8000a18:	4d84      	ldr	r5, [pc, #528]	; (8000c2c <HAL_RCC_OscConfig+0x2ec>)
 8000a1a:	68aa      	ldr	r2, [r5, #8]
 8000a1c:	4013      	ands	r3, r2
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 8000a1e:	68ea      	ldr	r2, [r5, #12]
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSI)) || (temp_sysclksrc == RCC_CFGR_SWS_HSI))
 8000a20:	2b10      	cmp	r3, #16
 8000a22:	d128      	bne.n	8000a76 <HAL_RCC_OscConfig+0x136>
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 8000a24:	2103      	movs	r1, #3
 8000a26:	400a      	ands	r2, r1
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSI)) || (temp_sysclksrc == RCC_CFGR_SWS_HSI))
 8000a28:	2a02      	cmp	r2, #2
 8000a2a:	d126      	bne.n	8000a7a <HAL_RCC_OscConfig+0x13a>
      if ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8000a2c:	682a      	ldr	r2, [r5, #0]
 8000a2e:	0552      	lsls	r2, r2, #21
 8000a30:	d503      	bpl.n	8000a3a <HAL_RCC_OscConfig+0xfa>
 8000a32:	68e2      	ldr	r2, [r4, #12]
 8000a34:	2a00      	cmp	r2, #0
 8000a36:	d100      	bne.n	8000a3a <HAL_RCC_OscConfig+0xfa>
 8000a38:	e787      	b.n	800094a <HAL_RCC_OscConfig+0xa>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000a3a:	6869      	ldr	r1, [r5, #4]
 8000a3c:	6962      	ldr	r2, [r4, #20]
 8000a3e:	487e      	ldr	r0, [pc, #504]	; (8000c38 <HAL_RCC_OscConfig+0x2f8>)
 8000a40:	0212      	lsls	r2, r2, #8
 8000a42:	4001      	ands	r1, r0
 8000a44:	430a      	orrs	r2, r1
 8000a46:	606a      	str	r2, [r5, #4]
        if (temp_sysclksrc == RCC_CFGR_SWS_HSI)
 8000a48:	2b00      	cmp	r3, #0
 8000a4a:	d10d      	bne.n	8000a68 <HAL_RCC_OscConfig+0x128>
          __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIDiv);
 8000a4c:	682b      	ldr	r3, [r5, #0]
 8000a4e:	4a7b      	ldr	r2, [pc, #492]	; (8000c3c <HAL_RCC_OscConfig+0x2fc>)
 8000a50:	4013      	ands	r3, r2
 8000a52:	6922      	ldr	r2, [r4, #16]
 8000a54:	4313      	orrs	r3, r2
 8000a56:	602b      	str	r3, [r5, #0]
          SystemCoreClock = (HSI_VALUE / (1UL << ((READ_BIT(RCC->CR, RCC_CR_HSIDIV)) >> RCC_CR_HSIDIV_Pos)));
 8000a58:	682b      	ldr	r3, [r5, #0]
 8000a5a:	4a79      	ldr	r2, [pc, #484]	; (8000c40 <HAL_RCC_OscConfig+0x300>)
 8000a5c:	049b      	lsls	r3, r3, #18
 8000a5e:	0f5b      	lsrs	r3, r3, #29
 8000a60:	40da      	lsrs	r2, r3
 8000a62:	0013      	movs	r3, r2
 8000a64:	4a77      	ldr	r2, [pc, #476]	; (8000c44 <HAL_RCC_OscConfig+0x304>)
 8000a66:	6013      	str	r3, [r2, #0]
        if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8000a68:	2000      	movs	r0, #0
 8000a6a:	f001 faf7 	bl	800205c <HAL_InitTick>
 8000a6e:	2800      	cmp	r0, #0
 8000a70:	d100      	bne.n	8000a74 <HAL_RCC_OscConfig+0x134>
 8000a72:	e773      	b.n	800095c <HAL_RCC_OscConfig+0x1c>
 8000a74:	e769      	b.n	800094a <HAL_RCC_OscConfig+0xa>
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSI)) || (temp_sysclksrc == RCC_CFGR_SWS_HSI))
 8000a76:	2b00      	cmp	r3, #0
 8000a78:	d0d8      	beq.n	8000a2c <HAL_RCC_OscConfig+0xec>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8000a7a:	68e3      	ldr	r3, [r4, #12]
 8000a7c:	2b00      	cmp	r3, #0
 8000a7e:	d020      	beq.n	8000ac2 <HAL_RCC_OscConfig+0x182>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIDiv);
 8000a80:	682b      	ldr	r3, [r5, #0]
 8000a82:	4a6e      	ldr	r2, [pc, #440]	; (8000c3c <HAL_RCC_OscConfig+0x2fc>)
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8000a84:	2680      	movs	r6, #128	; 0x80
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIDiv);
 8000a86:	4013      	ands	r3, r2
 8000a88:	6922      	ldr	r2, [r4, #16]
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8000a8a:	00f6      	lsls	r6, r6, #3
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIDiv);
 8000a8c:	4313      	orrs	r3, r2
 8000a8e:	602b      	str	r3, [r5, #0]
        __HAL_RCC_HSI_ENABLE();
 8000a90:	2380      	movs	r3, #128	; 0x80
 8000a92:	682a      	ldr	r2, [r5, #0]
 8000a94:	005b      	lsls	r3, r3, #1
 8000a96:	4313      	orrs	r3, r2
 8000a98:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8000a9a:	f7ff fbe1 	bl	8000260 <HAL_GetTick>
 8000a9e:	0007      	movs	r7, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8000aa0:	682b      	ldr	r3, [r5, #0]
 8000aa2:	4233      	tst	r3, r6
 8000aa4:	d007      	beq.n	8000ab6 <HAL_RCC_OscConfig+0x176>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000aa6:	686a      	ldr	r2, [r5, #4]
 8000aa8:	6963      	ldr	r3, [r4, #20]
 8000aaa:	4963      	ldr	r1, [pc, #396]	; (8000c38 <HAL_RCC_OscConfig+0x2f8>)
 8000aac:	021b      	lsls	r3, r3, #8
 8000aae:	400a      	ands	r2, r1
 8000ab0:	4313      	orrs	r3, r2
 8000ab2:	606b      	str	r3, [r5, #4]
 8000ab4:	e752      	b.n	800095c <HAL_RCC_OscConfig+0x1c>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8000ab6:	f7ff fbd3 	bl	8000260 <HAL_GetTick>
 8000aba:	1bc0      	subs	r0, r0, r7
 8000abc:	2802      	cmp	r0, #2
 8000abe:	d9ef      	bls.n	8000aa0 <HAL_RCC_OscConfig+0x160>
 8000ac0:	e782      	b.n	80009c8 <HAL_RCC_OscConfig+0x88>
        __HAL_RCC_HSI_DISABLE();
 8000ac2:	682b      	ldr	r3, [r5, #0]
 8000ac4:	4a60      	ldr	r2, [pc, #384]	; (8000c48 <HAL_RCC_OscConfig+0x308>)
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8000ac6:	2680      	movs	r6, #128	; 0x80
        __HAL_RCC_HSI_DISABLE();
 8000ac8:	4013      	ands	r3, r2
 8000aca:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8000acc:	f7ff fbc8 	bl	8000260 <HAL_GetTick>
 8000ad0:	0007      	movs	r7, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8000ad2:	00f6      	lsls	r6, r6, #3
 8000ad4:	682b      	ldr	r3, [r5, #0]
 8000ad6:	4233      	tst	r3, r6
 8000ad8:	d100      	bne.n	8000adc <HAL_RCC_OscConfig+0x19c>
 8000ada:	e73f      	b.n	800095c <HAL_RCC_OscConfig+0x1c>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8000adc:	f7ff fbc0 	bl	8000260 <HAL_GetTick>
 8000ae0:	1bc0      	subs	r0, r0, r7
 8000ae2:	2802      	cmp	r0, #2
 8000ae4:	d9f6      	bls.n	8000ad4 <HAL_RCC_OscConfig+0x194>
 8000ae6:	e76f      	b.n	80009c8 <HAL_RCC_OscConfig+0x88>
    if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_LSI)
 8000ae8:	2138      	movs	r1, #56	; 0x38
 8000aea:	4b50      	ldr	r3, [pc, #320]	; (8000c2c <HAL_RCC_OscConfig+0x2ec>)
 8000aec:	689a      	ldr	r2, [r3, #8]
 8000aee:	001d      	movs	r5, r3
 8000af0:	400a      	ands	r2, r1
 8000af2:	2a18      	cmp	r2, #24
 8000af4:	d108      	bne.n	8000b08 <HAL_RCC_OscConfig+0x1c8>
      if ((((RCC->CSR) & RCC_CSR_LSIRDY) != 0U) && (RCC_OscInitStruct->LSIState == RCC_LSI_OFF))
 8000af6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8000af8:	079b      	lsls	r3, r3, #30
 8000afa:	d400      	bmi.n	8000afe <HAL_RCC_OscConfig+0x1be>
 8000afc:	e732      	b.n	8000964 <HAL_RCC_OscConfig+0x24>
 8000afe:	69a3      	ldr	r3, [r4, #24]
 8000b00:	2b00      	cmp	r3, #0
 8000b02:	d000      	beq.n	8000b06 <HAL_RCC_OscConfig+0x1c6>
 8000b04:	e72e      	b.n	8000964 <HAL_RCC_OscConfig+0x24>
 8000b06:	e720      	b.n	800094a <HAL_RCC_OscConfig+0xa>
      if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8000b08:	69a2      	ldr	r2, [r4, #24]
 8000b0a:	2301      	movs	r3, #1
 8000b0c:	2a00      	cmp	r2, #0
 8000b0e:	d010      	beq.n	8000b32 <HAL_RCC_OscConfig+0x1f2>
        __HAL_RCC_LSI_ENABLE();
 8000b10:	6e2a      	ldr	r2, [r5, #96]	; 0x60
        while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 8000b12:	2602      	movs	r6, #2
        __HAL_RCC_LSI_ENABLE();
 8000b14:	4313      	orrs	r3, r2
 8000b16:	662b      	str	r3, [r5, #96]	; 0x60
        tickstart = HAL_GetTick();
 8000b18:	f7ff fba2 	bl	8000260 <HAL_GetTick>
 8000b1c:	0007      	movs	r7, r0
        while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 8000b1e:	6e2b      	ldr	r3, [r5, #96]	; 0x60
 8000b20:	4233      	tst	r3, r6
 8000b22:	d000      	beq.n	8000b26 <HAL_RCC_OscConfig+0x1e6>
 8000b24:	e71e      	b.n	8000964 <HAL_RCC_OscConfig+0x24>
          if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8000b26:	f7ff fb9b 	bl	8000260 <HAL_GetTick>
 8000b2a:	1bc0      	subs	r0, r0, r7
 8000b2c:	2802      	cmp	r0, #2
 8000b2e:	d9f6      	bls.n	8000b1e <HAL_RCC_OscConfig+0x1de>
 8000b30:	e74a      	b.n	80009c8 <HAL_RCC_OscConfig+0x88>
        __HAL_RCC_LSI_DISABLE();
 8000b32:	6e2a      	ldr	r2, [r5, #96]	; 0x60
        while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8000b34:	2602      	movs	r6, #2
        __HAL_RCC_LSI_DISABLE();
 8000b36:	439a      	bics	r2, r3
 8000b38:	662a      	str	r2, [r5, #96]	; 0x60
        tickstart = HAL_GetTick();
 8000b3a:	f7ff fb91 	bl	8000260 <HAL_GetTick>
 8000b3e:	0007      	movs	r7, r0
        while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8000b40:	6e2b      	ldr	r3, [r5, #96]	; 0x60
 8000b42:	4233      	tst	r3, r6
 8000b44:	d100      	bne.n	8000b48 <HAL_RCC_OscConfig+0x208>
 8000b46:	e70d      	b.n	8000964 <HAL_RCC_OscConfig+0x24>
          if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8000b48:	f7ff fb8a 	bl	8000260 <HAL_GetTick>
 8000b4c:	1bc0      	subs	r0, r0, r7
 8000b4e:	2802      	cmp	r0, #2
 8000b50:	d9f6      	bls.n	8000b40 <HAL_RCC_OscConfig+0x200>
 8000b52:	e739      	b.n	80009c8 <HAL_RCC_OscConfig+0x88>
    if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_LSE)
 8000b54:	2138      	movs	r1, #56	; 0x38
 8000b56:	4b35      	ldr	r3, [pc, #212]	; (8000c2c <HAL_RCC_OscConfig+0x2ec>)
 8000b58:	689a      	ldr	r2, [r3, #8]
 8000b5a:	001d      	movs	r5, r3
 8000b5c:	400a      	ands	r2, r1
 8000b5e:	2a20      	cmp	r2, #32
 8000b60:	d108      	bne.n	8000b74 <HAL_RCC_OscConfig+0x234>
      if ((((RCC->BDCR) & RCC_BDCR_LSERDY) != 0U) && (RCC_OscInitStruct->LSEState == RCC_LSE_OFF))
 8000b62:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8000b64:	079b      	lsls	r3, r3, #30
 8000b66:	d400      	bmi.n	8000b6a <HAL_RCC_OscConfig+0x22a>
 8000b68:	e700      	b.n	800096c <HAL_RCC_OscConfig+0x2c>
 8000b6a:	68a3      	ldr	r3, [r4, #8]
 8000b6c:	2b00      	cmp	r3, #0
 8000b6e:	d000      	beq.n	8000b72 <HAL_RCC_OscConfig+0x232>
 8000b70:	e6fc      	b.n	800096c <HAL_RCC_OscConfig+0x2c>
 8000b72:	e6ea      	b.n	800094a <HAL_RCC_OscConfig+0xa>
      if (__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 8000b74:	2280      	movs	r2, #128	; 0x80
 8000b76:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8000b78:	0552      	lsls	r2, r2, #21
 8000b7a:	4213      	tst	r3, r2
 8000b7c:	d100      	bne.n	8000b80 <HAL_RCC_OscConfig+0x240>
 8000b7e:	e0c3      	b.n	8000d08 <HAL_RCC_OscConfig+0x3c8>
    FlagStatus       pwrclkchanged = RESET;
 8000b80:	2300      	movs	r3, #0
      if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8000b82:	2780      	movs	r7, #128	; 0x80
 8000b84:	4e31      	ldr	r6, [pc, #196]	; (8000c4c <HAL_RCC_OscConfig+0x30c>)
    FlagStatus       pwrclkchanged = RESET;
 8000b86:	9300      	str	r3, [sp, #0]
      if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8000b88:	6833      	ldr	r3, [r6, #0]
 8000b8a:	007f      	lsls	r7, r7, #1
 8000b8c:	423b      	tst	r3, r7
 8000b8e:	d015      	beq.n	8000bbc <HAL_RCC_OscConfig+0x27c>
      __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000b90:	68a3      	ldr	r3, [r4, #8]
 8000b92:	2b01      	cmp	r3, #1
 8000b94:	d122      	bne.n	8000bdc <HAL_RCC_OscConfig+0x29c>
 8000b96:	6dea      	ldr	r2, [r5, #92]	; 0x5c
 8000b98:	4313      	orrs	r3, r2
 8000b9a:	65eb      	str	r3, [r5, #92]	; 0x5c
        tickstart = HAL_GetTick();
 8000b9c:	f7ff fb60 	bl	8000260 <HAL_GetTick>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8000ba0:	2702      	movs	r7, #2
        tickstart = HAL_GetTick();
 8000ba2:	0006      	movs	r6, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8000ba4:	6deb      	ldr	r3, [r5, #92]	; 0x5c
 8000ba6:	423b      	tst	r3, r7
 8000ba8:	d038      	beq.n	8000c1c <HAL_RCC_OscConfig+0x2dc>
      if (pwrclkchanged == SET)
 8000baa:	9b00      	ldr	r3, [sp, #0]
 8000bac:	2b01      	cmp	r3, #1
 8000bae:	d000      	beq.n	8000bb2 <HAL_RCC_OscConfig+0x272>
 8000bb0:	e6dc      	b.n	800096c <HAL_RCC_OscConfig+0x2c>
        __HAL_RCC_PWR_CLK_DISABLE();
 8000bb2:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8000bb4:	4a26      	ldr	r2, [pc, #152]	; (8000c50 <HAL_RCC_OscConfig+0x310>)
 8000bb6:	4013      	ands	r3, r2
 8000bb8:	63eb      	str	r3, [r5, #60]	; 0x3c
 8000bba:	e6d7      	b.n	800096c <HAL_RCC_OscConfig+0x2c>
        SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8000bbc:	6833      	ldr	r3, [r6, #0]
 8000bbe:	433b      	orrs	r3, r7
 8000bc0:	6033      	str	r3, [r6, #0]
        tickstart = HAL_GetTick();
 8000bc2:	f7ff fb4d 	bl	8000260 <HAL_GetTick>
 8000bc6:	9001      	str	r0, [sp, #4]
        while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8000bc8:	6833      	ldr	r3, [r6, #0]
 8000bca:	423b      	tst	r3, r7
 8000bcc:	d1e0      	bne.n	8000b90 <HAL_RCC_OscConfig+0x250>
          if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8000bce:	f7ff fb47 	bl	8000260 <HAL_GetTick>
 8000bd2:	9b01      	ldr	r3, [sp, #4]
 8000bd4:	1ac0      	subs	r0, r0, r3
 8000bd6:	2802      	cmp	r0, #2
 8000bd8:	d9f6      	bls.n	8000bc8 <HAL_RCC_OscConfig+0x288>
 8000bda:	e6f5      	b.n	80009c8 <HAL_RCC_OscConfig+0x88>
      __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000bdc:	6dea      	ldr	r2, [r5, #92]	; 0x5c
 8000bde:	2b05      	cmp	r3, #5
 8000be0:	d105      	bne.n	8000bee <HAL_RCC_OscConfig+0x2ae>
 8000be2:	3b01      	subs	r3, #1
 8000be4:	4313      	orrs	r3, r2
 8000be6:	65eb      	str	r3, [r5, #92]	; 0x5c
 8000be8:	6dea      	ldr	r2, [r5, #92]	; 0x5c
 8000bea:	2301      	movs	r3, #1
 8000bec:	e7d4      	b.n	8000b98 <HAL_RCC_OscConfig+0x258>
 8000bee:	2101      	movs	r1, #1
 8000bf0:	438a      	bics	r2, r1
 8000bf2:	65ea      	str	r2, [r5, #92]	; 0x5c
 8000bf4:	6dea      	ldr	r2, [r5, #92]	; 0x5c
 8000bf6:	3103      	adds	r1, #3
 8000bf8:	438a      	bics	r2, r1
 8000bfa:	65ea      	str	r2, [r5, #92]	; 0x5c
      if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8000bfc:	2b00      	cmp	r3, #0
 8000bfe:	d1cd      	bne.n	8000b9c <HAL_RCC_OscConfig+0x25c>
        tickstart = HAL_GetTick();
 8000c00:	f7ff fb2e 	bl	8000260 <HAL_GetTick>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8000c04:	2702      	movs	r7, #2
        tickstart = HAL_GetTick();
 8000c06:	0006      	movs	r6, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8000c08:	6deb      	ldr	r3, [r5, #92]	; 0x5c
 8000c0a:	423b      	tst	r3, r7
 8000c0c:	d0cd      	beq.n	8000baa <HAL_RCC_OscConfig+0x26a>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8000c0e:	f7ff fb27 	bl	8000260 <HAL_GetTick>
 8000c12:	4b10      	ldr	r3, [pc, #64]	; (8000c54 <HAL_RCC_OscConfig+0x314>)
 8000c14:	1b80      	subs	r0, r0, r6
 8000c16:	4298      	cmp	r0, r3
 8000c18:	d9f6      	bls.n	8000c08 <HAL_RCC_OscConfig+0x2c8>
 8000c1a:	e6d5      	b.n	80009c8 <HAL_RCC_OscConfig+0x88>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8000c1c:	f7ff fb20 	bl	8000260 <HAL_GetTick>
 8000c20:	4b0c      	ldr	r3, [pc, #48]	; (8000c54 <HAL_RCC_OscConfig+0x314>)
 8000c22:	1b80      	subs	r0, r0, r6
 8000c24:	4298      	cmp	r0, r3
 8000c26:	d9bd      	bls.n	8000ba4 <HAL_RCC_OscConfig+0x264>
 8000c28:	e6ce      	b.n	80009c8 <HAL_RCC_OscConfig+0x88>
 8000c2a:	46c0      	nop			; (mov r8, r8)
 8000c2c:	40021000 	.word	0x40021000
 8000c30:	fffeffff 	.word	0xfffeffff
 8000c34:	fffbffff 	.word	0xfffbffff
 8000c38:	ffff80ff 	.word	0xffff80ff
 8000c3c:	ffffc7ff 	.word	0xffffc7ff
 8000c40:	00f42400 	.word	0x00f42400
 8000c44:	20000008 	.word	0x20000008
 8000c48:	fffffeff 	.word	0xfffffeff
 8000c4c:	40007000 	.word	0x40007000
 8000c50:	efffffff 	.word	0xefffffff
 8000c54:	00001388 	.word	0x00001388
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8000c58:	2238      	movs	r2, #56	; 0x38
 8000c5a:	4d30      	ldr	r5, [pc, #192]	; (8000d1c <HAL_RCC_OscConfig+0x3dc>)
 8000c5c:	68ab      	ldr	r3, [r5, #8]
 8000c5e:	4013      	ands	r3, r2
 8000c60:	2b10      	cmp	r3, #16
 8000c62:	d100      	bne.n	8000c66 <HAL_RCC_OscConfig+0x326>
 8000c64:	e671      	b.n	800094a <HAL_RCC_OscConfig+0xa>
        __HAL_RCC_PLL_DISABLE();
 8000c66:	682b      	ldr	r3, [r5, #0]
 8000c68:	4a2d      	ldr	r2, [pc, #180]	; (8000d20 <HAL_RCC_OscConfig+0x3e0>)
 8000c6a:	4013      	ands	r3, r2
 8000c6c:	602b      	str	r3, [r5, #0]
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8000c6e:	2902      	cmp	r1, #2
 8000c70:	d133      	bne.n	8000cda <HAL_RCC_OscConfig+0x39a>
        tickstart = HAL_GetTick();
 8000c72:	f7ff faf5 	bl	8000260 <HAL_GetTick>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8000c76:	2680      	movs	r6, #128	; 0x80
        tickstart = HAL_GetTick();
 8000c78:	0007      	movs	r7, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8000c7a:	04b6      	lsls	r6, r6, #18
 8000c7c:	682b      	ldr	r3, [r5, #0]
 8000c7e:	4233      	tst	r3, r6
 8000c80:	d125      	bne.n	8000cce <HAL_RCC_OscConfig+0x38e>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000c82:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8000c84:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8000c86:	4313      	orrs	r3, r2
 8000c88:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000c8a:	4313      	orrs	r3, r2
 8000c8c:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8000c8e:	4313      	orrs	r3, r2
 8000c90:	6a22      	ldr	r2, [r4, #32]
 8000c92:	4313      	orrs	r3, r2
 8000c94:	6aa2      	ldr	r2, [r4, #40]	; 0x28
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8000c96:	2480      	movs	r4, #128	; 0x80
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000c98:	0212      	lsls	r2, r2, #8
 8000c9a:	4313      	orrs	r3, r2
 8000c9c:	60eb      	str	r3, [r5, #12]
        __HAL_RCC_PLL_ENABLE();
 8000c9e:	2380      	movs	r3, #128	; 0x80
 8000ca0:	682a      	ldr	r2, [r5, #0]
 8000ca2:	045b      	lsls	r3, r3, #17
 8000ca4:	4313      	orrs	r3, r2
 8000ca6:	602b      	str	r3, [r5, #0]
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLLRCLK);
 8000ca8:	2380      	movs	r3, #128	; 0x80
 8000caa:	68ea      	ldr	r2, [r5, #12]
 8000cac:	055b      	lsls	r3, r3, #21
 8000cae:	4313      	orrs	r3, r2
 8000cb0:	60eb      	str	r3, [r5, #12]
        tickstart = HAL_GetTick();
 8000cb2:	f7ff fad5 	bl	8000260 <HAL_GetTick>
 8000cb6:	0006      	movs	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8000cb8:	04a4      	lsls	r4, r4, #18
 8000cba:	682b      	ldr	r3, [r5, #0]
 8000cbc:	4223      	tst	r3, r4
 8000cbe:	d000      	beq.n	8000cc2 <HAL_RCC_OscConfig+0x382>
 8000cc0:	e658      	b.n	8000974 <HAL_RCC_OscConfig+0x34>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8000cc2:	f7ff facd 	bl	8000260 <HAL_GetTick>
 8000cc6:	1b80      	subs	r0, r0, r6
 8000cc8:	2802      	cmp	r0, #2
 8000cca:	d9f6      	bls.n	8000cba <HAL_RCC_OscConfig+0x37a>
 8000ccc:	e67c      	b.n	80009c8 <HAL_RCC_OscConfig+0x88>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8000cce:	f7ff fac7 	bl	8000260 <HAL_GetTick>
 8000cd2:	1bc0      	subs	r0, r0, r7
 8000cd4:	2802      	cmp	r0, #2
 8000cd6:	d9d1      	bls.n	8000c7c <HAL_RCC_OscConfig+0x33c>
 8000cd8:	e676      	b.n	80009c8 <HAL_RCC_OscConfig+0x88>
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
 8000cda:	2203      	movs	r2, #3
 8000cdc:	68eb      	ldr	r3, [r5, #12]
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8000cde:	2480      	movs	r4, #128	; 0x80
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
 8000ce0:	4393      	bics	r3, r2
 8000ce2:	60eb      	str	r3, [r5, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLLCFGR_PLLPEN | RCC_PLLCFGR_PLLQEN | RCC_PLLCFGR_PLLREN);
 8000ce4:	68eb      	ldr	r3, [r5, #12]
 8000ce6:	4a0f      	ldr	r2, [pc, #60]	; (8000d24 <HAL_RCC_OscConfig+0x3e4>)
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8000ce8:	04a4      	lsls	r4, r4, #18
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLLCFGR_PLLPEN | RCC_PLLCFGR_PLLQEN | RCC_PLLCFGR_PLLREN);
 8000cea:	4013      	ands	r3, r2
 8000cec:	60eb      	str	r3, [r5, #12]
        tickstart = HAL_GetTick();
 8000cee:	f7ff fab7 	bl	8000260 <HAL_GetTick>
 8000cf2:	0006      	movs	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8000cf4:	682b      	ldr	r3, [r5, #0]
 8000cf6:	4223      	tst	r3, r4
 8000cf8:	d100      	bne.n	8000cfc <HAL_RCC_OscConfig+0x3bc>
 8000cfa:	e63b      	b.n	8000974 <HAL_RCC_OscConfig+0x34>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8000cfc:	f7ff fab0 	bl	8000260 <HAL_GetTick>
 8000d00:	1b80      	subs	r0, r0, r6
 8000d02:	2802      	cmp	r0, #2
 8000d04:	d9f6      	bls.n	8000cf4 <HAL_RCC_OscConfig+0x3b4>
 8000d06:	e65f      	b.n	80009c8 <HAL_RCC_OscConfig+0x88>
        __HAL_RCC_PWR_CLK_ENABLE();
 8000d08:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8000d0a:	4313      	orrs	r3, r2
 8000d0c:	63eb      	str	r3, [r5, #60]	; 0x3c
 8000d0e:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8000d10:	4013      	ands	r3, r2
 8000d12:	9303      	str	r3, [sp, #12]
 8000d14:	9b03      	ldr	r3, [sp, #12]
        pwrclkchanged = SET;
 8000d16:	2301      	movs	r3, #1
 8000d18:	e733      	b.n	8000b82 <HAL_RCC_OscConfig+0x242>
 8000d1a:	46c0      	nop			; (mov r8, r8)
 8000d1c:	40021000 	.word	0x40021000
 8000d20:	feffffff 	.word	0xfeffffff
 8000d24:	eefeffff 	.word	0xeefeffff

08000d28 <HAL_RCC_GetSysClockFreq>:
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t pllvco, pllsource, pllr, pllm, hsidiv;
  uint32_t sysclockfreq;

  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
 8000d28:	2338      	movs	r3, #56	; 0x38
 8000d2a:	4a1f      	ldr	r2, [pc, #124]	; (8000da8 <HAL_RCC_GetSysClockFreq+0x80>)
{
 8000d2c:	b570      	push	{r4, r5, r6, lr}
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
 8000d2e:	6891      	ldr	r1, [r2, #8]
 8000d30:	0014      	movs	r4, r2
 8000d32:	4219      	tst	r1, r3
 8000d34:	d108      	bne.n	8000d48 <HAL_RCC_GetSysClockFreq+0x20>
  {
    /* HSISYS can be derived for HSI16 */
    hsidiv = (1UL << ((READ_BIT(RCC->CR, RCC_CR_HSIDIV)) >> RCC_CR_HSIDIV_Pos));
 8000d36:	2101      	movs	r1, #1
 8000d38:	6813      	ldr	r3, [r2, #0]

    /* HSI used as system clock source */
    sysclockfreq = (HSI_VALUE / hsidiv);
 8000d3a:	481c      	ldr	r0, [pc, #112]	; (8000dac <HAL_RCC_GetSysClockFreq+0x84>)
    hsidiv = (1UL << ((READ_BIT(RCC->CR, RCC_CR_HSIDIV)) >> RCC_CR_HSIDIV_Pos));
 8000d3c:	049b      	lsls	r3, r3, #18
 8000d3e:	0f5b      	lsrs	r3, r3, #29
 8000d40:	4099      	lsls	r1, r3
      default:                 /* HSI16 used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos) ;
        break;
    }
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U);
    sysclockfreq = pllvco / pllr;
 8000d42:	f7ff f9e1 	bl	8000108 <__udivsi3>
  {
    sysclockfreq = 0U;
  }

  return sysclockfreq;
}
 8000d46:	bd70      	pop	{r4, r5, r6, pc}
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
 8000d48:	6891      	ldr	r1, [r2, #8]
 8000d4a:	4019      	ands	r1, r3
 8000d4c:	2908      	cmp	r1, #8
 8000d4e:	d025      	beq.n	8000d9c <HAL_RCC_GetSysClockFreq+0x74>
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 8000d50:	6891      	ldr	r1, [r2, #8]
 8000d52:	4019      	ands	r1, r3
 8000d54:	2910      	cmp	r1, #16
 8000d56:	d115      	bne.n	8000d84 <HAL_RCC_GetSysClockFreq+0x5c>
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 8000d58:	68d3      	ldr	r3, [r2, #12]
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8000d5a:	68d1      	ldr	r1, [r2, #12]
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 8000d5c:	43db      	mvns	r3, r3
 8000d5e:	227f      	movs	r2, #127	; 0x7f
        pllvco =  (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8000d60:	68e5      	ldr	r5, [r4, #12]
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8000d62:	0649      	lsls	r1, r1, #25
 8000d64:	0f49      	lsrs	r1, r1, #29
        pllvco =  (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8000d66:	0a2d      	lsrs	r5, r5, #8
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8000d68:	3101      	adds	r1, #1
        pllvco =  (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8000d6a:	4015      	ands	r5, r2
    switch (pllsource)
 8000d6c:	079b      	lsls	r3, r3, #30
 8000d6e:	d107      	bne.n	8000d80 <HAL_RCC_GetSysClockFreq+0x58>
        pllvco =  (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8000d70:	480f      	ldr	r0, [pc, #60]	; (8000db0 <HAL_RCC_GetSysClockFreq+0x88>)
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos) ;
 8000d72:	f7ff f9c9 	bl	8000108 <__udivsi3>
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U);
 8000d76:	68e1      	ldr	r1, [r4, #12]
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos) ;
 8000d78:	4368      	muls	r0, r5
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U);
 8000d7a:	0f49      	lsrs	r1, r1, #29
 8000d7c:	3101      	adds	r1, #1
 8000d7e:	e7e0      	b.n	8000d42 <HAL_RCC_GetSysClockFreq+0x1a>
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos) ;
 8000d80:	480a      	ldr	r0, [pc, #40]	; (8000dac <HAL_RCC_GetSysClockFreq+0x84>)
 8000d82:	e7f6      	b.n	8000d72 <HAL_RCC_GetSysClockFreq+0x4a>
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_LSE)
 8000d84:	6891      	ldr	r1, [r2, #8]
 8000d86:	4019      	ands	r1, r3
 8000d88:	2920      	cmp	r1, #32
 8000d8a:	d009      	beq.n	8000da0 <HAL_RCC_GetSysClockFreq+0x78>
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_LSI)
 8000d8c:	6892      	ldr	r2, [r2, #8]
    sysclockfreq = 0U;
 8000d8e:	2000      	movs	r0, #0
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_LSI)
 8000d90:	4013      	ands	r3, r2
 8000d92:	2b18      	cmp	r3, #24
 8000d94:	d1d7      	bne.n	8000d46 <HAL_RCC_GetSysClockFreq+0x1e>
    sysclockfreq = LSI_VALUE;
 8000d96:	20fa      	movs	r0, #250	; 0xfa
 8000d98:	01c0      	lsls	r0, r0, #7
  return sysclockfreq;
 8000d9a:	e7d4      	b.n	8000d46 <HAL_RCC_GetSysClockFreq+0x1e>
    sysclockfreq = HSE_VALUE;
 8000d9c:	4804      	ldr	r0, [pc, #16]	; (8000db0 <HAL_RCC_GetSysClockFreq+0x88>)
 8000d9e:	e7d2      	b.n	8000d46 <HAL_RCC_GetSysClockFreq+0x1e>
    sysclockfreq = LSE_VALUE;
 8000da0:	2080      	movs	r0, #128	; 0x80
 8000da2:	0200      	lsls	r0, r0, #8
 8000da4:	e7cf      	b.n	8000d46 <HAL_RCC_GetSysClockFreq+0x1e>
 8000da6:	46c0      	nop			; (mov r8, r8)
 8000da8:	40021000 	.word	0x40021000
 8000dac:	00f42400 	.word	0x00f42400
 8000db0:	007a1200 	.word	0x007a1200

08000db4 <HAL_RCC_ClockConfig>:
{
 8000db4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8000db6:	0005      	movs	r5, r0
 8000db8:	000e      	movs	r6, r1
  if (RCC_ClkInitStruct == NULL)
 8000dba:	2800      	cmp	r0, #0
 8000dbc:	d101      	bne.n	8000dc2 <HAL_RCC_ClockConfig+0xe>
    return HAL_ERROR;
 8000dbe:	2001      	movs	r0, #1
}
 8000dc0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8000dc2:	2707      	movs	r7, #7
 8000dc4:	4c49      	ldr	r4, [pc, #292]	; (8000eec <HAL_RCC_ClockConfig+0x138>)
 8000dc6:	6823      	ldr	r3, [r4, #0]
 8000dc8:	403b      	ands	r3, r7
 8000dca:	428b      	cmp	r3, r1
 8000dcc:	d329      	bcc.n	8000e22 <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8000dce:	6829      	ldr	r1, [r5, #0]
 8000dd0:	078b      	lsls	r3, r1, #30
 8000dd2:	d43a      	bmi.n	8000e4a <HAL_RCC_ClockConfig+0x96>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8000dd4:	07cb      	lsls	r3, r1, #31
 8000dd6:	d447      	bmi.n	8000e68 <HAL_RCC_ClockConfig+0xb4>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8000dd8:	2707      	movs	r7, #7
 8000dda:	6823      	ldr	r3, [r4, #0]
 8000ddc:	403b      	ands	r3, r7
 8000dde:	429e      	cmp	r6, r3
 8000de0:	d20a      	bcs.n	8000df8 <HAL_RCC_ClockConfig+0x44>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000de2:	6823      	ldr	r3, [r4, #0]
 8000de4:	43bb      	bics	r3, r7
 8000de6:	4333      	orrs	r3, r6
 8000de8:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 8000dea:	f7ff fa39 	bl	8000260 <HAL_GetTick>
 8000dee:	9001      	str	r0, [sp, #4]
    while ((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8000df0:	6823      	ldr	r3, [r4, #0]
 8000df2:	403b      	ands	r3, r7
 8000df4:	429e      	cmp	r6, r3
 8000df6:	d16a      	bne.n	8000ece <HAL_RCC_ClockConfig+0x11a>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8000df8:	682b      	ldr	r3, [r5, #0]
 8000dfa:	4c3d      	ldr	r4, [pc, #244]	; (8000ef0 <HAL_RCC_ClockConfig+0x13c>)
 8000dfc:	075b      	lsls	r3, r3, #29
 8000dfe:	d46e      	bmi.n	8000ede <HAL_RCC_ClockConfig+0x12a>
  SystemCoreClock = (HAL_RCC_GetSysClockFreq() >> ((AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos]) & 0x1FU));
 8000e00:	f7ff ff92 	bl	8000d28 <HAL_RCC_GetSysClockFreq>
 8000e04:	68a3      	ldr	r3, [r4, #8]
 8000e06:	4a3b      	ldr	r2, [pc, #236]	; (8000ef4 <HAL_RCC_ClockConfig+0x140>)
 8000e08:	051b      	lsls	r3, r3, #20
 8000e0a:	0f1b      	lsrs	r3, r3, #28
 8000e0c:	009b      	lsls	r3, r3, #2
 8000e0e:	589b      	ldr	r3, [r3, r2]
 8000e10:	221f      	movs	r2, #31
 8000e12:	4013      	ands	r3, r2
 8000e14:	40d8      	lsrs	r0, r3
 8000e16:	4b38      	ldr	r3, [pc, #224]	; (8000ef8 <HAL_RCC_ClockConfig+0x144>)
 8000e18:	6018      	str	r0, [r3, #0]
  return HAL_InitTick(TICK_INT_PRIORITY);
 8000e1a:	2000      	movs	r0, #0
 8000e1c:	f001 f91e 	bl	800205c <HAL_InitTick>
 8000e20:	e7ce      	b.n	8000dc0 <HAL_RCC_ClockConfig+0xc>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000e22:	6823      	ldr	r3, [r4, #0]
 8000e24:	43bb      	bics	r3, r7
 8000e26:	430b      	orrs	r3, r1
 8000e28:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 8000e2a:	f7ff fa19 	bl	8000260 <HAL_GetTick>
 8000e2e:	9001      	str	r0, [sp, #4]
    while ((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8000e30:	6823      	ldr	r3, [r4, #0]
 8000e32:	403b      	ands	r3, r7
 8000e34:	429e      	cmp	r6, r3
 8000e36:	d0ca      	beq.n	8000dce <HAL_RCC_ClockConfig+0x1a>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000e38:	f7ff fa12 	bl	8000260 <HAL_GetTick>
 8000e3c:	9b01      	ldr	r3, [sp, #4]
 8000e3e:	1ac0      	subs	r0, r0, r3
 8000e40:	4b2e      	ldr	r3, [pc, #184]	; (8000efc <HAL_RCC_ClockConfig+0x148>)
 8000e42:	4298      	cmp	r0, r3
 8000e44:	d9f4      	bls.n	8000e30 <HAL_RCC_ClockConfig+0x7c>
        return HAL_TIMEOUT;
 8000e46:	2003      	movs	r0, #3
 8000e48:	e7ba      	b.n	8000dc0 <HAL_RCC_ClockConfig+0xc>
 8000e4a:	4a29      	ldr	r2, [pc, #164]	; (8000ef0 <HAL_RCC_ClockConfig+0x13c>)
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8000e4c:	074b      	lsls	r3, r1, #29
 8000e4e:	d504      	bpl.n	8000e5a <HAL_RCC_ClockConfig+0xa6>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_HCLK_DIV16);
 8000e50:	23e0      	movs	r3, #224	; 0xe0
 8000e52:	6890      	ldr	r0, [r2, #8]
 8000e54:	01db      	lsls	r3, r3, #7
 8000e56:	4303      	orrs	r3, r0
 8000e58:	6093      	str	r3, [r2, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8000e5a:	6893      	ldr	r3, [r2, #8]
 8000e5c:	4828      	ldr	r0, [pc, #160]	; (8000f00 <HAL_RCC_ClockConfig+0x14c>)
 8000e5e:	4003      	ands	r3, r0
 8000e60:	68a8      	ldr	r0, [r5, #8]
 8000e62:	4303      	orrs	r3, r0
 8000e64:	6093      	str	r3, [r2, #8]
 8000e66:	e7b5      	b.n	8000dd4 <HAL_RCC_ClockConfig+0x20>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000e68:	686a      	ldr	r2, [r5, #4]
 8000e6a:	4f21      	ldr	r7, [pc, #132]	; (8000ef0 <HAL_RCC_ClockConfig+0x13c>)
 8000e6c:	2a01      	cmp	r2, #1
 8000e6e:	d119      	bne.n	8000ea4 <HAL_RCC_ClockConfig+0xf0>
      if (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8000e70:	683b      	ldr	r3, [r7, #0]
 8000e72:	039b      	lsls	r3, r3, #14
 8000e74:	d5a3      	bpl.n	8000dbe <HAL_RCC_ClockConfig+0xa>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8000e76:	2107      	movs	r1, #7
 8000e78:	68bb      	ldr	r3, [r7, #8]
 8000e7a:	438b      	bics	r3, r1
 8000e7c:	4313      	orrs	r3, r2
 8000e7e:	60bb      	str	r3, [r7, #8]
    tickstart = HAL_GetTick();
 8000e80:	f7ff f9ee 	bl	8000260 <HAL_GetTick>
 8000e84:	9001      	str	r0, [sp, #4]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8000e86:	2338      	movs	r3, #56	; 0x38
 8000e88:	68ba      	ldr	r2, [r7, #8]
 8000e8a:	401a      	ands	r2, r3
 8000e8c:	686b      	ldr	r3, [r5, #4]
 8000e8e:	00db      	lsls	r3, r3, #3
 8000e90:	429a      	cmp	r2, r3
 8000e92:	d0a1      	beq.n	8000dd8 <HAL_RCC_ClockConfig+0x24>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000e94:	f7ff f9e4 	bl	8000260 <HAL_GetTick>
 8000e98:	9b01      	ldr	r3, [sp, #4]
 8000e9a:	1ac0      	subs	r0, r0, r3
 8000e9c:	4b17      	ldr	r3, [pc, #92]	; (8000efc <HAL_RCC_ClockConfig+0x148>)
 8000e9e:	4298      	cmp	r0, r3
 8000ea0:	d9f1      	bls.n	8000e86 <HAL_RCC_ClockConfig+0xd2>
 8000ea2:	e7d0      	b.n	8000e46 <HAL_RCC_ClockConfig+0x92>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000ea4:	2a02      	cmp	r2, #2
 8000ea6:	d103      	bne.n	8000eb0 <HAL_RCC_ClockConfig+0xfc>
      if (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8000ea8:	683b      	ldr	r3, [r7, #0]
 8000eaa:	019b      	lsls	r3, r3, #6
 8000eac:	d4e3      	bmi.n	8000e76 <HAL_RCC_ClockConfig+0xc2>
 8000eae:	e786      	b.n	8000dbe <HAL_RCC_ClockConfig+0xa>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 8000eb0:	2a00      	cmp	r2, #0
 8000eb2:	d103      	bne.n	8000ebc <HAL_RCC_ClockConfig+0x108>
      if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8000eb4:	683b      	ldr	r3, [r7, #0]
 8000eb6:	055b      	lsls	r3, r3, #21
 8000eb8:	d4dd      	bmi.n	8000e76 <HAL_RCC_ClockConfig+0xc2>
 8000eba:	e780      	b.n	8000dbe <HAL_RCC_ClockConfig+0xa>
 8000ebc:	2302      	movs	r3, #2
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_LSI)
 8000ebe:	2a03      	cmp	r2, #3
 8000ec0:	d103      	bne.n	8000eca <HAL_RCC_ClockConfig+0x116>
      if (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 8000ec2:	6e39      	ldr	r1, [r7, #96]	; 0x60
      if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8000ec4:	4219      	tst	r1, r3
 8000ec6:	d1d6      	bne.n	8000e76 <HAL_RCC_ClockConfig+0xc2>
 8000ec8:	e779      	b.n	8000dbe <HAL_RCC_ClockConfig+0xa>
 8000eca:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 8000ecc:	e7fa      	b.n	8000ec4 <HAL_RCC_ClockConfig+0x110>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000ece:	f7ff f9c7 	bl	8000260 <HAL_GetTick>
 8000ed2:	9b01      	ldr	r3, [sp, #4]
 8000ed4:	1ac0      	subs	r0, r0, r3
 8000ed6:	4b09      	ldr	r3, [pc, #36]	; (8000efc <HAL_RCC_ClockConfig+0x148>)
 8000ed8:	4298      	cmp	r0, r3
 8000eda:	d989      	bls.n	8000df0 <HAL_RCC_ClockConfig+0x3c>
 8000edc:	e7b3      	b.n	8000e46 <HAL_RCC_ClockConfig+0x92>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_ClkInitStruct->APB1CLKDivider);
 8000ede:	68a3      	ldr	r3, [r4, #8]
 8000ee0:	4a08      	ldr	r2, [pc, #32]	; (8000f04 <HAL_RCC_ClockConfig+0x150>)
 8000ee2:	4013      	ands	r3, r2
 8000ee4:	68ea      	ldr	r2, [r5, #12]
 8000ee6:	4313      	orrs	r3, r2
 8000ee8:	60a3      	str	r3, [r4, #8]
 8000eea:	e789      	b.n	8000e00 <HAL_RCC_ClockConfig+0x4c>
 8000eec:	40022000 	.word	0x40022000
 8000ef0:	40021000 	.word	0x40021000
 8000ef4:	080021ec 	.word	0x080021ec
 8000ef8:	20000008 	.word	0x20000008
 8000efc:	00001388 	.word	0x00001388
 8000f00:	fffff0ff 	.word	0xfffff0ff
 8000f04:	ffff8fff 	.word	0xffff8fff

08000f08 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE) >> RCC_CFGR_PPRE_Pos]) & 0x1FU));
 8000f08:	4b06      	ldr	r3, [pc, #24]	; (8000f24 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8000f0a:	4a07      	ldr	r2, [pc, #28]	; (8000f28 <HAL_RCC_GetPCLK1Freq+0x20>)
 8000f0c:	689b      	ldr	r3, [r3, #8]
 8000f0e:	045b      	lsls	r3, r3, #17
 8000f10:	0f5b      	lsrs	r3, r3, #29
 8000f12:	009b      	lsls	r3, r3, #2
 8000f14:	589b      	ldr	r3, [r3, r2]
 8000f16:	221f      	movs	r2, #31
 8000f18:	4013      	ands	r3, r2
 8000f1a:	4a04      	ldr	r2, [pc, #16]	; (8000f2c <HAL_RCC_GetPCLK1Freq+0x24>)
 8000f1c:	6810      	ldr	r0, [r2, #0]
 8000f1e:	40d8      	lsrs	r0, r3
}
 8000f20:	4770      	bx	lr
 8000f22:	46c0      	nop			; (mov r8, r8)
 8000f24:	40021000 	.word	0x40021000
 8000f28:	0800222c 	.word	0x0800222c
 8000f2c:	20000008 	.word	0x20000008

08000f30 <HAL_RCC_GetClockConfig>:
  /* Check the parameters */
  assert_param(RCC_ClkInitStruct != (void *)NULL);
  assert_param(pFLatency != (void *)NULL);

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1;
 8000f30:	2207      	movs	r2, #7
{
 8000f32:	b530      	push	{r4, r5, lr}

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 8000f34:	25f0      	movs	r5, #240	; 0xf0
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8000f36:	4b09      	ldr	r3, [pc, #36]	; (8000f5c <HAL_RCC_GetClockConfig+0x2c>)
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1;
 8000f38:	6002      	str	r2, [r0, #0]
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8000f3a:	689c      	ldr	r4, [r3, #8]
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 8000f3c:	012d      	lsls	r5, r5, #4
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8000f3e:	4014      	ands	r4, r2
 8000f40:	6044      	str	r4, [r0, #4]
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 8000f42:	689c      	ldr	r4, [r3, #8]
 8000f44:	402c      	ands	r4, r5
 8000f46:	6084      	str	r4, [r0, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE);
 8000f48:	24e0      	movs	r4, #224	; 0xe0
 8000f4a:	689b      	ldr	r3, [r3, #8]
 8000f4c:	01e4      	lsls	r4, r4, #7
 8000f4e:	4023      	ands	r3, r4
 8000f50:	60c3      	str	r3, [r0, #12]


  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8000f52:	4b03      	ldr	r3, [pc, #12]	; (8000f60 <HAL_RCC_GetClockConfig+0x30>)
 8000f54:	681b      	ldr	r3, [r3, #0]
 8000f56:	4013      	ands	r3, r2
 8000f58:	600b      	str	r3, [r1, #0]
}
 8000f5a:	bd30      	pop	{r4, r5, pc}
 8000f5c:	40021000 	.word	0x40021000
 8000f60:	40022000 	.word	0x40022000

08000f64 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8000f64:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000f66:	0005      	movs	r5, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8000f68:	682b      	ldr	r3, [r5, #0]
{
 8000f6a:	b085      	sub	sp, #20
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 8000f6c:	2000      	movs	r0, #0
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8000f6e:	039b      	lsls	r3, r3, #14
 8000f70:	d550      	bpl.n	8001014 <HAL_RCCEx_PeriphCLKConfig+0xb0>

    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000f72:	2280      	movs	r2, #128	; 0x80
 8000f74:	4c6f      	ldr	r4, [pc, #444]	; (8001134 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8000f76:	0552      	lsls	r2, r2, #21
 8000f78:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    FlagStatus       pwrclkchanged = RESET;
 8000f7a:	9000      	str	r0, [sp, #0]
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000f7c:	4213      	tst	r3, r2
 8000f7e:	d108      	bne.n	8000f92 <HAL_RCCEx_PeriphCLKConfig+0x2e>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8000f80:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8000f82:	4313      	orrs	r3, r2
 8000f84:	63e3      	str	r3, [r4, #60]	; 0x3c
 8000f86:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8000f88:	4013      	ands	r3, r2
 8000f8a:	9303      	str	r3, [sp, #12]
 8000f8c:	9b03      	ldr	r3, [sp, #12]
      pwrclkchanged = SET;
 8000f8e:	2301      	movs	r3, #1
 8000f90:	9300      	str	r3, [sp, #0]
    }

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8000f92:	2780      	movs	r7, #128	; 0x80
 8000f94:	4e68      	ldr	r6, [pc, #416]	; (8001138 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 8000f96:	007f      	lsls	r7, r7, #1
 8000f98:	6833      	ldr	r3, [r6, #0]
 8000f9a:	433b      	orrs	r3, r7
 8000f9c:	6033      	str	r3, [r6, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8000f9e:	f7ff f95f 	bl	8000260 <HAL_GetTick>
 8000fa2:	9001      	str	r0, [sp, #4]

    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8000fa4:	6833      	ldr	r3, [r6, #0]
 8000fa6:	423b      	tst	r3, r7
 8000fa8:	d026      	beq.n	8000ff8 <HAL_RCCEx_PeriphCLKConfig+0x94>
    }

    if (ret == HAL_OK)
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8000faa:	23c0      	movs	r3, #192	; 0xc0
 8000fac:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8000fae:	009b      	lsls	r3, r3, #2
 8000fb0:	4013      	ands	r3, r2

      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if ((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 8000fb2:	d00f      	beq.n	8000fd4 <HAL_RCCEx_PeriphCLKConfig+0x70>
 8000fb4:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8000fb6:	4293      	cmp	r3, r2
 8000fb8:	d00c      	beq.n	8000fd4 <HAL_RCCEx_PeriphCLKConfig+0x70>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8000fba:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8000fbc:	4b5f      	ldr	r3, [pc, #380]	; (800113c <HAL_RCCEx_PeriphCLKConfig+0x1d8>)
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 8000fbe:	6de1      	ldr	r1, [r4, #92]	; 0x5c
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8000fc0:	4013      	ands	r3, r2
        __HAL_RCC_BACKUPRESET_FORCE();
 8000fc2:	2280      	movs	r2, #128	; 0x80
 8000fc4:	0252      	lsls	r2, r2, #9
 8000fc6:	430a      	orrs	r2, r1
 8000fc8:	65e2      	str	r2, [r4, #92]	; 0x5c
        __HAL_RCC_BACKUPRESET_RELEASE();
 8000fca:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8000fcc:	495c      	ldr	r1, [pc, #368]	; (8001140 <HAL_RCCEx_PeriphCLKConfig+0x1dc>)
 8000fce:	400a      	ands	r2, r1
 8000fd0:	65e2      	str	r2, [r4, #92]	; 0x5c
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
 8000fd2:	65e3      	str	r3, [r4, #92]	; 0x5c
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8000fd4:	07db      	lsls	r3, r3, #31
 8000fd6:	d507      	bpl.n	8000fe8 <HAL_RCCEx_PeriphCLKConfig+0x84>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000fd8:	f7ff f942 	bl	8000260 <HAL_GetTick>

        /* Wait till LSE is ready */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8000fdc:	2702      	movs	r7, #2
        tickstart = HAL_GetTick();
 8000fde:	0006      	movs	r6, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8000fe0:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8000fe2:	423b      	tst	r3, r7
 8000fe4:	d100      	bne.n	8000fe8 <HAL_RCCEx_PeriphCLKConfig+0x84>
 8000fe6:	e09d      	b.n	8001124 <HAL_RCCEx_PeriphCLKConfig+0x1c0>
      }

      if (ret == HAL_OK)
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8000fe8:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8000fea:	4a54      	ldr	r2, [pc, #336]	; (800113c <HAL_RCCEx_PeriphCLKConfig+0x1d8>)
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 8000fec:	2000      	movs	r0, #0
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8000fee:	4013      	ands	r3, r2
 8000ff0:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8000ff2:	4313      	orrs	r3, r2
 8000ff4:	65e3      	str	r3, [r4, #92]	; 0x5c
 8000ff6:	e006      	b.n	8001006 <HAL_RCCEx_PeriphCLKConfig+0xa2>
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8000ff8:	f7ff f932 	bl	8000260 <HAL_GetTick>
 8000ffc:	9b01      	ldr	r3, [sp, #4]
 8000ffe:	1ac0      	subs	r0, r0, r3
 8001000:	2802      	cmp	r0, #2
 8001002:	d9cf      	bls.n	8000fa4 <HAL_RCCEx_PeriphCLKConfig+0x40>
        ret = HAL_TIMEOUT;
 8001004:	2003      	movs	r0, #3
      /* set overall return value */
      status = ret;
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 8001006:	9b00      	ldr	r3, [sp, #0]
 8001008:	2b01      	cmp	r3, #1
 800100a:	d103      	bne.n	8001014 <HAL_RCCEx_PeriphCLKConfig+0xb0>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800100c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800100e:	4a4d      	ldr	r2, [pc, #308]	; (8001144 <HAL_RCCEx_PeriphCLKConfig+0x1e0>)
 8001010:	4013      	ands	r3, r2
 8001012:	63e3      	str	r3, [r4, #60]	; 0x3c
    }
  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8001014:	682b      	ldr	r3, [r5, #0]
 8001016:	07da      	lsls	r2, r3, #31
 8001018:	d506      	bpl.n	8001028 <HAL_RCCEx_PeriphCLKConfig+0xc4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800101a:	2403      	movs	r4, #3
 800101c:	4945      	ldr	r1, [pc, #276]	; (8001134 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800101e:	6d4a      	ldr	r2, [r1, #84]	; 0x54
 8001020:	43a2      	bics	r2, r4
 8001022:	686c      	ldr	r4, [r5, #4]
 8001024:	4322      	orrs	r2, r4
 8001026:	654a      	str	r2, [r1, #84]	; 0x54
  }

#if defined(RCC_CCIPR_USART2SEL)
  /*-------------------------- USART2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8001028:	079a      	lsls	r2, r3, #30
 800102a:	d506      	bpl.n	800103a <HAL_RCCEx_PeriphCLKConfig+0xd6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 800102c:	240c      	movs	r4, #12
 800102e:	4941      	ldr	r1, [pc, #260]	; (8001134 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8001030:	6d4a      	ldr	r2, [r1, #84]	; 0x54
 8001032:	43a2      	bics	r2, r4
 8001034:	68ac      	ldr	r4, [r5, #8]
 8001036:	4322      	orrs	r2, r4
 8001038:	654a      	str	r2, [r1, #84]	; 0x54
  }
#endif /* RCC_CCIPR_USART2SEL */

#if defined(RCC_CCIPR_LPUART1SEL)
  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 800103a:	069a      	lsls	r2, r3, #26
 800103c:	d506      	bpl.n	800104c <HAL_RCCEx_PeriphCLKConfig+0xe8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 800103e:	493d      	ldr	r1, [pc, #244]	; (8001134 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8001040:	4c41      	ldr	r4, [pc, #260]	; (8001148 <HAL_RCCEx_PeriphCLKConfig+0x1e4>)
 8001042:	6d4a      	ldr	r2, [r1, #84]	; 0x54
 8001044:	4022      	ands	r2, r4
 8001046:	68ec      	ldr	r4, [r5, #12]
 8001048:	4322      	orrs	r2, r4
 800104a:	654a      	str	r2, [r1, #84]	; 0x54
  }
#endif /* RCC_CCIPR_LPUART1SEL */

#if defined(RCC_CCIPR_LPTIM1SEL)
  /*-------------------------- LPTIM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 800104c:	059a      	lsls	r2, r3, #22
 800104e:	d506      	bpl.n	800105e <HAL_RCCEx_PeriphCLKConfig+0xfa>
  {
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8001050:	4938      	ldr	r1, [pc, #224]	; (8001134 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8001052:	4c3e      	ldr	r4, [pc, #248]	; (800114c <HAL_RCCEx_PeriphCLKConfig+0x1e8>)
 8001054:	6d4a      	ldr	r2, [r1, #84]	; 0x54
 8001056:	4022      	ands	r2, r4
 8001058:	69ac      	ldr	r4, [r5, #24]
 800105a:	4322      	orrs	r2, r4
 800105c:	654a      	str	r2, [r1, #84]	; 0x54
  }
#endif /* RCC_CCIPR_LPTIM1SEL */

#if defined(RCC_CCIPR_LPTIM2SEL)
  /*-------------------------- LPTIM2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 800105e:	055a      	lsls	r2, r3, #21
 8001060:	d506      	bpl.n	8001070 <HAL_RCCEx_PeriphCLKConfig+0x10c>
  {
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8001062:	4934      	ldr	r1, [pc, #208]	; (8001134 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8001064:	4c3a      	ldr	r4, [pc, #232]	; (8001150 <HAL_RCCEx_PeriphCLKConfig+0x1ec>)
 8001066:	6d4a      	ldr	r2, [r1, #84]	; 0x54
 8001068:	4022      	ands	r2, r4
 800106a:	69ec      	ldr	r4, [r5, #28]
 800106c:	4322      	orrs	r2, r4
 800106e:	654a      	str	r2, [r1, #84]	; 0x54
  }
#endif /* RCC_CCIPR_LPTIM2SEL */

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8001070:	065a      	lsls	r2, r3, #25
 8001072:	d506      	bpl.n	8001082 <HAL_RCCEx_PeriphCLKConfig+0x11e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8001074:	492f      	ldr	r1, [pc, #188]	; (8001134 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8001076:	4c37      	ldr	r4, [pc, #220]	; (8001154 <HAL_RCCEx_PeriphCLKConfig+0x1f0>)
 8001078:	6d4a      	ldr	r2, [r1, #84]	; 0x54
 800107a:	4022      	ands	r2, r4
 800107c:	692c      	ldr	r4, [r5, #16]
 800107e:	4322      	orrs	r2, r4
 8001080:	654a      	str	r2, [r1, #84]	; 0x54
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLLQCLK);
    }
  }
#endif /* RCC_CCIPR_RNGSEL */
  /*-------------------------- ADC clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8001082:	045a      	lsls	r2, r3, #17
 8001084:	d50f      	bpl.n	80010a6 <HAL_RCCEx_PeriphCLKConfig+0x142>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8001086:	492b      	ldr	r1, [pc, #172]	; (8001134 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8001088:	6a2c      	ldr	r4, [r5, #32]
 800108a:	6d4a      	ldr	r2, [r1, #84]	; 0x54
 800108c:	0092      	lsls	r2, r2, #2
 800108e:	0892      	lsrs	r2, r2, #2
 8001090:	4322      	orrs	r2, r4
 8001092:	654a      	str	r2, [r1, #84]	; 0x54

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLADC)
 8001094:	2280      	movs	r2, #128	; 0x80
 8001096:	05d2      	lsls	r2, r2, #23
 8001098:	4294      	cmp	r4, r2
 800109a:	d104      	bne.n	80010a6 <HAL_RCCEx_PeriphCLKConfig+0x142>
    {
      /* Enable PLLPCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLLPCLK);
 800109c:	2280      	movs	r2, #128	; 0x80
 800109e:	68cc      	ldr	r4, [r1, #12]
 80010a0:	0252      	lsls	r2, r2, #9
 80010a2:	4322      	orrs	r2, r4
 80010a4:	60ca      	str	r2, [r1, #12]
    }
  }

#if defined(RCC_CCIPR_CECSEL)
  /*-------------------------- CEC clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 80010a6:	031a      	lsls	r2, r3, #12
 80010a8:	d506      	bpl.n	80010b8 <HAL_RCCEx_PeriphCLKConfig+0x154>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 80010aa:	2440      	movs	r4, #64	; 0x40
 80010ac:	4921      	ldr	r1, [pc, #132]	; (8001134 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 80010ae:	6d4a      	ldr	r2, [r1, #84]	; 0x54
 80010b0:	43a2      	bics	r2, r4
 80010b2:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 80010b4:	4322      	orrs	r2, r4
 80010b6:	654a      	str	r2, [r1, #84]	; 0x54
  }
#endif /* RCC_CCIPR_CECSEL */

#if defined(RCC_CCIPR_TIM1SEL)
  /*-------------------------- TIM1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM1) == RCC_PERIPHCLK_TIM1)
 80010b8:	029a      	lsls	r2, r3, #10
 80010ba:	d50f      	bpl.n	80010dc <HAL_RCCEx_PeriphCLKConfig+0x178>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM1CLKSOURCE(PeriphClkInit->Tim1ClockSelection));

    /* Configure the TIM1 clock source */
    __HAL_RCC_TIM1_CONFIG(PeriphClkInit->Tim1ClockSelection);
 80010bc:	491d      	ldr	r1, [pc, #116]	; (8001134 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 80010be:	4e26      	ldr	r6, [pc, #152]	; (8001158 <HAL_RCCEx_PeriphCLKConfig+0x1f4>)
 80010c0:	6d4a      	ldr	r2, [r1, #84]	; 0x54
 80010c2:	6aac      	ldr	r4, [r5, #40]	; 0x28
 80010c4:	4032      	ands	r2, r6
 80010c6:	4322      	orrs	r2, r4
 80010c8:	654a      	str	r2, [r1, #84]	; 0x54

    if (PeriphClkInit->Tim1ClockSelection == RCC_TIM1CLKSOURCE_PLL)
 80010ca:	2280      	movs	r2, #128	; 0x80
 80010cc:	03d2      	lsls	r2, r2, #15
 80010ce:	4294      	cmp	r4, r2
 80010d0:	d104      	bne.n	80010dc <HAL_RCCEx_PeriphCLKConfig+0x178>
    {
      /* Enable PLLQCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLLQCLK);
 80010d2:	2280      	movs	r2, #128	; 0x80
 80010d4:	68cc      	ldr	r4, [r1, #12]
 80010d6:	0452      	lsls	r2, r2, #17
 80010d8:	4322      	orrs	r2, r4
 80010da:	60ca      	str	r2, [r1, #12]
  }
#endif /* RCC_CCIPR_TIM1SEL */

#if defined(RCC_CCIPR_TIM15SEL)
  /*-------------------------- TIM15 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM15) == RCC_PERIPHCLK_TIM15)
 80010dc:	025a      	lsls	r2, r3, #9
 80010de:	d50d      	bpl.n	80010fc <HAL_RCCEx_PeriphCLKConfig+0x198>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM15CLKSOURCE(PeriphClkInit->Tim15ClockSelection));

    /* Configure the TIM15 clock source */
    __HAL_RCC_TIM15_CONFIG(PeriphClkInit->Tim15ClockSelection);
 80010e0:	4c14      	ldr	r4, [pc, #80]	; (8001134 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 80010e2:	4e1e      	ldr	r6, [pc, #120]	; (800115c <HAL_RCCEx_PeriphCLKConfig+0x1f8>)
 80010e4:	6d61      	ldr	r1, [r4, #84]	; 0x54
 80010e6:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 80010e8:	4031      	ands	r1, r6
 80010ea:	4311      	orrs	r1, r2
 80010ec:	6561      	str	r1, [r4, #84]	; 0x54

    if (PeriphClkInit->Tim15ClockSelection == RCC_TIM15CLKSOURCE_PLL)
 80010ee:	2180      	movs	r1, #128	; 0x80
 80010f0:	0449      	lsls	r1, r1, #17
 80010f2:	428a      	cmp	r2, r1
 80010f4:	d102      	bne.n	80010fc <HAL_RCCEx_PeriphCLKConfig+0x198>
    {
      /* Enable PLLQCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLLQCLK);
 80010f6:	68e1      	ldr	r1, [r4, #12]
 80010f8:	430a      	orrs	r2, r1
 80010fa:	60e2      	str	r2, [r4, #12]
    }
  }
#endif /* RCC_CCIPR_TIM15SEL */

  /*-------------------------- I2S1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S1) == RCC_PERIPHCLK_I2S1)
 80010fc:	051b      	lsls	r3, r3, #20
 80010fe:	d50f      	bpl.n	8001120 <HAL_RCCEx_PeriphCLKConfig+0x1bc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2S1CLKSOURCE(PeriphClkInit->I2s1ClockSelection));

    /* Configure the I2S1 clock source */
    __HAL_RCC_I2S1_CONFIG(PeriphClkInit->I2s1ClockSelection);
 8001100:	490c      	ldr	r1, [pc, #48]	; (8001134 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8001102:	4c17      	ldr	r4, [pc, #92]	; (8001160 <HAL_RCCEx_PeriphCLKConfig+0x1fc>)
 8001104:	6d4b      	ldr	r3, [r1, #84]	; 0x54
 8001106:	696a      	ldr	r2, [r5, #20]
 8001108:	4023      	ands	r3, r4
 800110a:	4313      	orrs	r3, r2
 800110c:	654b      	str	r3, [r1, #84]	; 0x54

    if (PeriphClkInit->I2s1ClockSelection == RCC_I2S1CLKSOURCE_PLL)
 800110e:	2380      	movs	r3, #128	; 0x80
 8001110:	01db      	lsls	r3, r3, #7
 8001112:	429a      	cmp	r2, r3
 8001114:	d104      	bne.n	8001120 <HAL_RCCEx_PeriphCLKConfig+0x1bc>
    {
      /* Enable PLLPCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLLPCLK);
 8001116:	2380      	movs	r3, #128	; 0x80
 8001118:	68ca      	ldr	r2, [r1, #12]
 800111a:	025b      	lsls	r3, r3, #9
 800111c:	4313      	orrs	r3, r2
 800111e:	60cb      	str	r3, [r1, #12]
    }
  }

  return status;
}
 8001120:	b005      	add	sp, #20
 8001122:	bdf0      	pop	{r4, r5, r6, r7, pc}
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001124:	f7ff f89c 	bl	8000260 <HAL_GetTick>
 8001128:	4b0e      	ldr	r3, [pc, #56]	; (8001164 <HAL_RCCEx_PeriphCLKConfig+0x200>)
 800112a:	1b80      	subs	r0, r0, r6
 800112c:	4298      	cmp	r0, r3
 800112e:	d800      	bhi.n	8001132 <HAL_RCCEx_PeriphCLKConfig+0x1ce>
 8001130:	e756      	b.n	8000fe0 <HAL_RCCEx_PeriphCLKConfig+0x7c>
 8001132:	e767      	b.n	8001004 <HAL_RCCEx_PeriphCLKConfig+0xa0>
 8001134:	40021000 	.word	0x40021000
 8001138:	40007000 	.word	0x40007000
 800113c:	fffffcff 	.word	0xfffffcff
 8001140:	fffeffff 	.word	0xfffeffff
 8001144:	efffffff 	.word	0xefffffff
 8001148:	fffff3ff 	.word	0xfffff3ff
 800114c:	fff3ffff 	.word	0xfff3ffff
 8001150:	ffcfffff 	.word	0xffcfffff
 8001154:	ffffcfff 	.word	0xffffcfff
 8001158:	ffbfffff 	.word	0xffbfffff
 800115c:	feffffff 	.word	0xfeffffff
 8001160:	ffff3fff 	.word	0xffff3fff
 8001164:	00001388 	.word	0x00001388

08001168 <HAL_TIM_Base_MspInit>:
 8001168:	4770      	bx	lr
	...

0800116c <HAL_TIM_Base_Start_IT>:

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800116c:	2201      	movs	r2, #1
 800116e:	6803      	ldr	r3, [r0, #0]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8001170:	4807      	ldr	r0, [pc, #28]	; (8001190 <HAL_TIM_Base_Start_IT+0x24>)
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8001172:	68d9      	ldr	r1, [r3, #12]
 8001174:	4311      	orrs	r1, r2
 8001176:	60d9      	str	r1, [r3, #12]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8001178:	6899      	ldr	r1, [r3, #8]
 800117a:	4001      	ands	r1, r0
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800117c:	2906      	cmp	r1, #6
 800117e:	d005      	beq.n	800118c <HAL_TIM_Base_Start_IT+0x20>
 8001180:	3807      	subs	r0, #7
 8001182:	4281      	cmp	r1, r0
 8001184:	d002      	beq.n	800118c <HAL_TIM_Base_Start_IT+0x20>
  {
  __HAL_TIM_ENABLE(htim);
 8001186:	6819      	ldr	r1, [r3, #0]
 8001188:	430a      	orrs	r2, r1
 800118a:	601a      	str	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
}
 800118c:	2000      	movs	r0, #0
 800118e:	4770      	bx	lr
 8001190:	00010007 	.word	0x00010007

08001194 <HAL_TIM_OC_DelayElapsedCallback>:
 8001194:	4770      	bx	lr

08001196 <HAL_TIM_IC_CaptureCallback>:
 8001196:	4770      	bx	lr

08001198 <HAL_TIM_PWM_PulseFinishedCallback>:
 8001198:	4770      	bx	lr

0800119a <HAL_TIM_TriggerCallback>:
 800119a:	4770      	bx	lr

0800119c <HAL_TIM_IRQHandler>:
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
  /* Capture compare 1 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800119c:	2202      	movs	r2, #2
 800119e:	6803      	ldr	r3, [r0, #0]
{
 80011a0:	b510      	push	{r4, lr}
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80011a2:	6919      	ldr	r1, [r3, #16]
{
 80011a4:	0004      	movs	r4, r0
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80011a6:	4211      	tst	r1, r2
 80011a8:	d00e      	beq.n	80011c8 <HAL_TIM_IRQHandler+0x2c>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 80011aa:	68d9      	ldr	r1, [r3, #12]
 80011ac:	4211      	tst	r1, r2
 80011ae:	d00b      	beq.n	80011c8 <HAL_TIM_IRQHandler+0x2c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 80011b0:	3a05      	subs	r2, #5
 80011b2:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;

        /* Input capture event */
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 80011b4:	699b      	ldr	r3, [r3, #24]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 80011b6:	3204      	adds	r2, #4
 80011b8:	7702      	strb	r2, [r0, #28]
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 80011ba:	079b      	lsls	r3, r3, #30
 80011bc:	d100      	bne.n	80011c0 <HAL_TIM_IRQHandler+0x24>
 80011be:	e086      	b.n	80012ce <HAL_TIM_IRQHandler+0x132>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 80011c0:	f7ff ffe9 	bl	8001196 <HAL_TIM_IC_CaptureCallback>
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
          HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80011c4:	2300      	movs	r3, #0
 80011c6:	7723      	strb	r3, [r4, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 80011c8:	2204      	movs	r2, #4
 80011ca:	6823      	ldr	r3, [r4, #0]
 80011cc:	6919      	ldr	r1, [r3, #16]
 80011ce:	4211      	tst	r1, r2
 80011d0:	d011      	beq.n	80011f6 <HAL_TIM_IRQHandler+0x5a>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 80011d2:	68d9      	ldr	r1, [r3, #12]
 80011d4:	4211      	tst	r1, r2
 80011d6:	d00e      	beq.n	80011f6 <HAL_TIM_IRQHandler+0x5a>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 80011d8:	3a09      	subs	r2, #9
 80011da:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 80011dc:	3207      	adds	r2, #7
 80011de:	7722      	strb	r2, [r4, #28]
      /* Input capture event */
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 80011e0:	699a      	ldr	r2, [r3, #24]
 80011e2:	23c0      	movs	r3, #192	; 0xc0
 80011e4:	009b      	lsls	r3, r3, #2
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 80011e6:	0020      	movs	r0, r4
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 80011e8:	421a      	tst	r2, r3
 80011ea:	d100      	bne.n	80011ee <HAL_TIM_IRQHandler+0x52>
 80011ec:	e075      	b.n	80012da <HAL_TIM_IRQHandler+0x13e>
        HAL_TIM_IC_CaptureCallback(htim);
 80011ee:	f7ff ffd2 	bl	8001196 <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80011f2:	2300      	movs	r3, #0
 80011f4:	7723      	strb	r3, [r4, #28]
    }
  }
  /* Capture compare 3 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 80011f6:	2208      	movs	r2, #8
 80011f8:	6823      	ldr	r3, [r4, #0]
 80011fa:	6919      	ldr	r1, [r3, #16]
 80011fc:	4211      	tst	r1, r2
 80011fe:	d00e      	beq.n	800121e <HAL_TIM_IRQHandler+0x82>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8001200:	68d9      	ldr	r1, [r3, #12]
 8001202:	4211      	tst	r1, r2
 8001204:	d00b      	beq.n	800121e <HAL_TIM_IRQHandler+0x82>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8001206:	3a11      	subs	r2, #17
 8001208:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800120a:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800120c:	320d      	adds	r2, #13
 800120e:	7722      	strb	r2, [r4, #28]
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8001210:	0020      	movs	r0, r4
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8001212:	079b      	lsls	r3, r3, #30
 8001214:	d067      	beq.n	80012e6 <HAL_TIM_IRQHandler+0x14a>
        HAL_TIM_IC_CaptureCallback(htim);
 8001216:	f7ff ffbe 	bl	8001196 <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800121a:	2300      	movs	r3, #0
 800121c:	7723      	strb	r3, [r4, #28]
    }
  }
  /* Capture compare 4 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 800121e:	2210      	movs	r2, #16
 8001220:	6823      	ldr	r3, [r4, #0]
 8001222:	6919      	ldr	r1, [r3, #16]
 8001224:	4211      	tst	r1, r2
 8001226:	d010      	beq.n	800124a <HAL_TIM_IRQHandler+0xae>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8001228:	68d9      	ldr	r1, [r3, #12]
 800122a:	4211      	tst	r1, r2
 800122c:	d00d      	beq.n	800124a <HAL_TIM_IRQHandler+0xae>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 800122e:	3a21      	subs	r2, #33	; 0x21
 8001230:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8001232:	3219      	adds	r2, #25
 8001234:	7722      	strb	r2, [r4, #28]
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8001236:	69da      	ldr	r2, [r3, #28]
 8001238:	23c0      	movs	r3, #192	; 0xc0
 800123a:	009b      	lsls	r3, r3, #2
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800123c:	0020      	movs	r0, r4
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800123e:	421a      	tst	r2, r3
 8001240:	d057      	beq.n	80012f2 <HAL_TIM_IRQHandler+0x156>
        HAL_TIM_IC_CaptureCallback(htim);
 8001242:	f7ff ffa8 	bl	8001196 <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001246:	2300      	movs	r3, #0
 8001248:	7723      	strb	r3, [r4, #28]
    }
  }
  /* TIM Update event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 800124a:	2201      	movs	r2, #1
 800124c:	6823      	ldr	r3, [r4, #0]
 800124e:	6919      	ldr	r1, [r3, #16]
 8001250:	4211      	tst	r1, r2
 8001252:	d007      	beq.n	8001264 <HAL_TIM_IRQHandler+0xc8>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8001254:	68d9      	ldr	r1, [r3, #12]
 8001256:	4211      	tst	r1, r2
 8001258:	d004      	beq.n	8001264 <HAL_TIM_IRQHandler+0xc8>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800125a:	3a03      	subs	r2, #3
 800125c:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 800125e:	0020      	movs	r0, r4
 8001260:	f000 fea8 	bl	8001fb4 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8001264:	2280      	movs	r2, #128	; 0x80
 8001266:	6823      	ldr	r3, [r4, #0]
 8001268:	6919      	ldr	r1, [r3, #16]
 800126a:	4211      	tst	r1, r2
 800126c:	d008      	beq.n	8001280 <HAL_TIM_IRQHandler+0xe4>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800126e:	68d9      	ldr	r1, [r3, #12]
 8001270:	4211      	tst	r1, r2
 8001272:	d005      	beq.n	8001280 <HAL_TIM_IRQHandler+0xe4>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8001274:	3a02      	subs	r2, #2
 8001276:	3aff      	subs	r2, #255	; 0xff
 8001278:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 800127a:	0020      	movs	r0, r4
 800127c:	f000 f8ae 	bl	80013dc <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8001280:	6823      	ldr	r3, [r4, #0]
 8001282:	691a      	ldr	r2, [r3, #16]
 8001284:	05d2      	lsls	r2, r2, #23
 8001286:	d507      	bpl.n	8001298 <HAL_TIM_IRQHandler+0xfc>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8001288:	68da      	ldr	r2, [r3, #12]
 800128a:	0612      	lsls	r2, r2, #24
 800128c:	d504      	bpl.n	8001298 <HAL_TIM_IRQHandler+0xfc>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 800128e:	4a1c      	ldr	r2, [pc, #112]	; (8001300 <HAL_TIM_IRQHandler+0x164>)
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
 8001290:	0020      	movs	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8001292:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 8001294:	f000 f8a3 	bl	80013de <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8001298:	2240      	movs	r2, #64	; 0x40
 800129a:	6823      	ldr	r3, [r4, #0]
 800129c:	6919      	ldr	r1, [r3, #16]
 800129e:	4211      	tst	r1, r2
 80012a0:	d007      	beq.n	80012b2 <HAL_TIM_IRQHandler+0x116>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 80012a2:	68d9      	ldr	r1, [r3, #12]
 80012a4:	4211      	tst	r1, r2
 80012a6:	d004      	beq.n	80012b2 <HAL_TIM_IRQHandler+0x116>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 80012a8:	3a81      	subs	r2, #129	; 0x81
 80012aa:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 80012ac:	0020      	movs	r0, r4
 80012ae:	f7ff ff74 	bl	800119a <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 80012b2:	2220      	movs	r2, #32
 80012b4:	6823      	ldr	r3, [r4, #0]
 80012b6:	6919      	ldr	r1, [r3, #16]
 80012b8:	4211      	tst	r1, r2
 80012ba:	d007      	beq.n	80012cc <HAL_TIM_IRQHandler+0x130>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 80012bc:	68d9      	ldr	r1, [r3, #12]
 80012be:	4211      	tst	r1, r2
 80012c0:	d004      	beq.n	80012cc <HAL_TIM_IRQHandler+0x130>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 80012c2:	3a41      	subs	r2, #65	; 0x41
 80012c4:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 80012c6:	0020      	movs	r0, r4
 80012c8:	f000 f887 	bl	80013da <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 80012cc:	bd10      	pop	{r4, pc}
          HAL_TIM_OC_DelayElapsedCallback(htim);
 80012ce:	f7ff ff61 	bl	8001194 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 80012d2:	0020      	movs	r0, r4
 80012d4:	f7ff ff60 	bl	8001198 <HAL_TIM_PWM_PulseFinishedCallback>
 80012d8:	e774      	b.n	80011c4 <HAL_TIM_IRQHandler+0x28>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80012da:	f7ff ff5b 	bl	8001194 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80012de:	0020      	movs	r0, r4
 80012e0:	f7ff ff5a 	bl	8001198 <HAL_TIM_PWM_PulseFinishedCallback>
 80012e4:	e785      	b.n	80011f2 <HAL_TIM_IRQHandler+0x56>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80012e6:	f7ff ff55 	bl	8001194 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80012ea:	0020      	movs	r0, r4
 80012ec:	f7ff ff54 	bl	8001198 <HAL_TIM_PWM_PulseFinishedCallback>
 80012f0:	e793      	b.n	800121a <HAL_TIM_IRQHandler+0x7e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80012f2:	f7ff ff4f 	bl	8001194 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80012f6:	0020      	movs	r0, r4
 80012f8:	f7ff ff4e 	bl	8001198 <HAL_TIM_PWM_PulseFinishedCallback>
 80012fc:	e7a3      	b.n	8001246 <HAL_TIM_IRQHandler+0xaa>
 80012fe:	46c0      	nop			; (mov r8, r8)
 8001300:	fffffeff 	.word	0xfffffeff

08001304 <TIM_Base_SetConfig>:
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8001304:	4a20      	ldr	r2, [pc, #128]	; (8001388 <TIM_Base_SetConfig+0x84>)
{
 8001306:	b510      	push	{r4, lr}
  tmpcr1 = TIMx->CR1;
 8001308:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800130a:	4290      	cmp	r0, r2
 800130c:	d006      	beq.n	800131c <TIM_Base_SetConfig+0x18>
 800130e:	2480      	movs	r4, #128	; 0x80
 8001310:	05e4      	lsls	r4, r4, #23
 8001312:	42a0      	cmp	r0, r4
 8001314:	d002      	beq.n	800131c <TIM_Base_SetConfig+0x18>
 8001316:	4c1d      	ldr	r4, [pc, #116]	; (800138c <TIM_Base_SetConfig+0x88>)
 8001318:	42a0      	cmp	r0, r4
 800131a:	d10c      	bne.n	8001336 <TIM_Base_SetConfig+0x32>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800131c:	2470      	movs	r4, #112	; 0x70
 800131e:	43a3      	bics	r3, r4
    tmpcr1 |= Structure->CounterMode;
 8001320:	684c      	ldr	r4, [r1, #4]
 8001322:	4323      	orrs	r3, r4
  }

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8001324:	4290      	cmp	r0, r2
 8001326:	d012      	beq.n	800134e <TIM_Base_SetConfig+0x4a>
 8001328:	2480      	movs	r4, #128	; 0x80
 800132a:	05e4      	lsls	r4, r4, #23
 800132c:	42a0      	cmp	r0, r4
 800132e:	d00e      	beq.n	800134e <TIM_Base_SetConfig+0x4a>
 8001330:	4c16      	ldr	r4, [pc, #88]	; (800138c <TIM_Base_SetConfig+0x88>)
 8001332:	42a0      	cmp	r0, r4
 8001334:	d00b      	beq.n	800134e <TIM_Base_SetConfig+0x4a>
 8001336:	4c16      	ldr	r4, [pc, #88]	; (8001390 <TIM_Base_SetConfig+0x8c>)
 8001338:	42a0      	cmp	r0, r4
 800133a:	d008      	beq.n	800134e <TIM_Base_SetConfig+0x4a>
 800133c:	4c15      	ldr	r4, [pc, #84]	; (8001394 <TIM_Base_SetConfig+0x90>)
 800133e:	42a0      	cmp	r0, r4
 8001340:	d005      	beq.n	800134e <TIM_Base_SetConfig+0x4a>
 8001342:	4c15      	ldr	r4, [pc, #84]	; (8001398 <TIM_Base_SetConfig+0x94>)
 8001344:	42a0      	cmp	r0, r4
 8001346:	d002      	beq.n	800134e <TIM_Base_SetConfig+0x4a>
 8001348:	4c14      	ldr	r4, [pc, #80]	; (800139c <TIM_Base_SetConfig+0x98>)
 800134a:	42a0      	cmp	r0, r4
 800134c:	d103      	bne.n	8001356 <TIM_Base_SetConfig+0x52>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 800134e:	4c14      	ldr	r4, [pc, #80]	; (80013a0 <TIM_Base_SetConfig+0x9c>)
 8001350:	4023      	ands	r3, r4
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8001352:	68cc      	ldr	r4, [r1, #12]
 8001354:	4323      	orrs	r3, r4
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8001356:	2480      	movs	r4, #128	; 0x80
 8001358:	43a3      	bics	r3, r4
 800135a:	694c      	ldr	r4, [r1, #20]
 800135c:	4323      	orrs	r3, r4

  TIMx->CR1 = tmpcr1;
 800135e:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8001360:	688b      	ldr	r3, [r1, #8]
 8001362:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8001364:	680b      	ldr	r3, [r1, #0]
 8001366:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8001368:	4290      	cmp	r0, r2
 800136a:	d008      	beq.n	800137e <TIM_Base_SetConfig+0x7a>
 800136c:	4b09      	ldr	r3, [pc, #36]	; (8001394 <TIM_Base_SetConfig+0x90>)
 800136e:	4298      	cmp	r0, r3
 8001370:	d005      	beq.n	800137e <TIM_Base_SetConfig+0x7a>
 8001372:	4b09      	ldr	r3, [pc, #36]	; (8001398 <TIM_Base_SetConfig+0x94>)
 8001374:	4298      	cmp	r0, r3
 8001376:	d002      	beq.n	800137e <TIM_Base_SetConfig+0x7a>
 8001378:	4b08      	ldr	r3, [pc, #32]	; (800139c <TIM_Base_SetConfig+0x98>)
 800137a:	4298      	cmp	r0, r3
 800137c:	d101      	bne.n	8001382 <TIM_Base_SetConfig+0x7e>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 800137e:	690b      	ldr	r3, [r1, #16]
 8001380:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8001382:	2301      	movs	r3, #1
 8001384:	6143      	str	r3, [r0, #20]
}
 8001386:	bd10      	pop	{r4, pc}
 8001388:	40012c00 	.word	0x40012c00
 800138c:	40000400 	.word	0x40000400
 8001390:	40002000 	.word	0x40002000
 8001394:	40014000 	.word	0x40014000
 8001398:	40014400 	.word	0x40014400
 800139c:	40014800 	.word	0x40014800
 80013a0:	fffffcff 	.word	0xfffffcff

080013a4 <HAL_TIM_Base_Init>:
{
 80013a4:	b570      	push	{r4, r5, r6, lr}
 80013a6:	0004      	movs	r4, r0
    return HAL_ERROR;
 80013a8:	2001      	movs	r0, #1
  if(htim == NULL)
 80013aa:	2c00      	cmp	r4, #0
 80013ac:	d014      	beq.n	80013d8 <HAL_TIM_Base_Init+0x34>
  if(htim->State == HAL_TIM_STATE_RESET)
 80013ae:	0025      	movs	r5, r4
 80013b0:	353d      	adds	r5, #61	; 0x3d
 80013b2:	782b      	ldrb	r3, [r5, #0]
 80013b4:	b2db      	uxtb	r3, r3
 80013b6:	2b00      	cmp	r3, #0
 80013b8:	d105      	bne.n	80013c6 <HAL_TIM_Base_Init+0x22>
    htim->Lock = HAL_UNLOCKED;
 80013ba:	0022      	movs	r2, r4
 80013bc:	323c      	adds	r2, #60	; 0x3c
 80013be:	7013      	strb	r3, [r2, #0]
    HAL_TIM_Base_MspInit(htim);
 80013c0:	0020      	movs	r0, r4
 80013c2:	f7ff fed1 	bl	8001168 <HAL_TIM_Base_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;
 80013c6:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80013c8:	6820      	ldr	r0, [r4, #0]
  htim->State= HAL_TIM_STATE_BUSY;
 80013ca:	702b      	strb	r3, [r5, #0]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80013cc:	1d21      	adds	r1, r4, #4
 80013ce:	f7ff ff99 	bl	8001304 <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 80013d2:	2301      	movs	r3, #1
  return HAL_OK;
 80013d4:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
 80013d6:	702b      	strb	r3, [r5, #0]
}
 80013d8:	bd70      	pop	{r4, r5, r6, pc}

080013da <HAL_TIMEx_CommutCallback>:
 80013da:	4770      	bx	lr

080013dc <HAL_TIMEx_BreakCallback>:
 80013dc:	4770      	bx	lr

080013de <HAL_TIMEx_Break2Callback>:
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 80013de:	4770      	bx	lr

080013e0 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 80013e0:	b510      	push	{r4, lr}
  vTaskStartScheduler();
 80013e2:	f000 fb47 	bl	8001a74 <vTaskStartScheduler>
  
  return osOK;
}
 80013e6:	2000      	movs	r0, #0
 80013e8:	bd10      	pop	{r4, pc}

080013ea <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 80013ea:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 80013ec:	000b      	movs	r3, r1

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 80013ee:	6846      	ldr	r6, [r0, #4]
 80013f0:	6801      	ldr	r1, [r0, #0]
 80013f2:	8a02      	ldrh	r2, [r0, #16]
 80013f4:	2508      	movs	r5, #8
 80013f6:	5f45      	ldrsh	r5, [r0, r5]
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 80013f8:	2400      	movs	r4, #0
  if (priority != osPriorityError) {
 80013fa:	2d84      	cmp	r5, #132	; 0x84
 80013fc:	d000      	beq.n	8001400 <osThreadCreate+0x16>
    fpriority += (priority - osPriorityIdle);
 80013fe:	1cec      	adds	r4, r5, #3
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8001400:	a803      	add	r0, sp, #12
 8001402:	9001      	str	r0, [sp, #4]
 8001404:	9400      	str	r4, [sp, #0]
 8001406:	0030      	movs	r0, r6
 8001408:	f000 fa70 	bl	80018ec <xTaskCreate>
                   thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
                   &handle) != pdPASS)  {
    return NULL;
 800140c:	2300      	movs	r3, #0
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800140e:	2801      	cmp	r0, #1
 8001410:	d100      	bne.n	8001414 <osThreadCreate+0x2a>
  }     
#endif
  
  return handle;
 8001412:	9b03      	ldr	r3, [sp, #12]
}
 8001414:	0018      	movs	r0, r3
 8001416:	b004      	add	sp, #16
 8001418:	bd70      	pop	{r4, r5, r6, pc}

0800141a <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 800141a:	b510      	push	{r4, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 800141c:	2800      	cmp	r0, #0
 800141e:	d100      	bne.n	8001422 <osDelay+0x8>
 8001420:	3001      	adds	r0, #1
 8001422:	f000 fc3f 	bl	8001ca4 <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 8001426:	2000      	movs	r0, #0
 8001428:	bd10      	pop	{r4, pc}

0800142a <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800142a:	0003      	movs	r3, r0

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800142c:	2201      	movs	r2, #1
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800142e:	3308      	adds	r3, #8
 8001430:	6043      	str	r3, [r0, #4]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001432:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001434:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8001436:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8001438:	4252      	negs	r2, r2
 800143a:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800143c:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 800143e:	4770      	bx	lr

08001440 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8001440:	2300      	movs	r3, #0
 8001442:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8001444:	4770      	bx	lr

08001446 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8001446:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8001448:	689a      	ldr	r2, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
 800144a:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800144c:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800144e:	689a      	ldr	r2, [r3, #8]
 8001450:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8001452:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8001454:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8001456:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8001458:	3301      	adds	r3, #1
 800145a:	6003      	str	r3, [r0, #0]
}
 800145c:	4770      	bx	lr

0800145e <vListInsert>:
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800145e:	0003      	movs	r3, r0
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8001460:	680a      	ldr	r2, [r1, #0]
{
 8001462:	b530      	push	{r4, r5, lr}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001464:	3308      	adds	r3, #8
	if( xValueOfInsertion == portMAX_DELAY )
 8001466:	1c54      	adds	r4, r2, #1
 8001468:	d10b      	bne.n	8001482 <vListInsert+0x24>
		pxIterator = pxList->xListEnd.pxPrevious;
 800146a:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 800146c:	685a      	ldr	r2, [r3, #4]
 800146e:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8001470:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8001472:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8001474:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8001476:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8001478:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800147a:	3301      	adds	r3, #1
 800147c:	6003      	str	r3, [r0, #0]
}
 800147e:	bd30      	pop	{r4, r5, pc}
 8001480:	0023      	movs	r3, r4
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001482:	685c      	ldr	r4, [r3, #4]
 8001484:	6825      	ldr	r5, [r4, #0]
 8001486:	42aa      	cmp	r2, r5
 8001488:	d2fa      	bcs.n	8001480 <vListInsert+0x22>
 800148a:	e7ef      	b.n	800146c <vListInsert+0xe>

0800148c <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800148c:	6841      	ldr	r1, [r0, #4]
 800148e:	6882      	ldr	r2, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8001490:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8001492:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8001494:	6882      	ldr	r2, [r0, #8]
 8001496:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8001498:	6859      	ldr	r1, [r3, #4]
 800149a:	4288      	cmp	r0, r1
 800149c:	d100      	bne.n	80014a0 <uxListRemove+0x14>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 800149e:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 80014a0:	2200      	movs	r2, #0
 80014a2:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 80014a4:	681a      	ldr	r2, [r3, #0]
 80014a6:	3a01      	subs	r2, #1
 80014a8:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 80014aa:	6818      	ldr	r0, [r3, #0]
}
 80014ac:	4770      	bx	lr
	...

080014b0 <prvTaskExitError>:
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
volatile uint32_t ulDummy = 0UL;
 80014b0:	2300      	movs	r3, #0
{
 80014b2:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0UL;
 80014b4:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 80014b6:	4b06      	ldr	r3, [pc, #24]	; (80014d0 <prvTaskExitError+0x20>)
 80014b8:	681b      	ldr	r3, [r3, #0]
 80014ba:	3301      	adds	r3, #1
 80014bc:	d001      	beq.n	80014c2 <prvTaskExitError+0x12>
 80014be:	b672      	cpsid	i
 80014c0:	e7fe      	b.n	80014c0 <prvTaskExitError+0x10>
	portDISABLE_INTERRUPTS();
 80014c2:	b672      	cpsid	i
	while( ulDummy == 0 )
 80014c4:	9b01      	ldr	r3, [sp, #4]
 80014c6:	2b00      	cmp	r3, #0
 80014c8:	d0fc      	beq.n	80014c4 <prvTaskExitError+0x14>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 80014ca:	b002      	add	sp, #8
 80014cc:	4770      	bx	lr
 80014ce:	46c0      	nop			; (mov r8, r8)
 80014d0:	20000004 	.word	0x20000004
	...

080014e0 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
 80014e0:	4a0b      	ldr	r2, [pc, #44]	; (8001510 <pxCurrentTCBConst2>)
 80014e2:	6813      	ldr	r3, [r2, #0]
 80014e4:	6818      	ldr	r0, [r3, #0]
 80014e6:	3020      	adds	r0, #32
 80014e8:	f380 8809 	msr	PSP, r0
 80014ec:	2002      	movs	r0, #2
 80014ee:	f380 8814 	msr	CONTROL, r0
 80014f2:	f3bf 8f6f 	isb	sy
 80014f6:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
 80014f8:	46ae      	mov	lr, r5
 80014fa:	bc08      	pop	{r3}
 80014fc:	bc04      	pop	{r2}
 80014fe:	b662      	cpsie	i
 8001500:	4718      	bx	r3
 8001502:	46c0      	nop			; (mov r8, r8)
 8001504:	46c0      	nop			; (mov r8, r8)
 8001506:	46c0      	nop			; (mov r8, r8)
 8001508:	46c0      	nop			; (mov r8, r8)
 800150a:	46c0      	nop			; (mov r8, r8)
 800150c:	46c0      	nop			; (mov r8, r8)
 800150e:	46c0      	nop			; (mov r8, r8)

08001510 <pxCurrentTCBConst2>:
 8001510:	20000c40 	.word	0x20000c40

08001514 <pxPortInitialiseStack>:
{
 8001514:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8001516:	2480      	movs	r4, #128	; 0x80
 8001518:	1f03      	subs	r3, r0, #4
 800151a:	0464      	lsls	r4, r4, #17
 800151c:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
 800151e:	3b04      	subs	r3, #4
 8001520:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8001522:	4903      	ldr	r1, [pc, #12]	; (8001530 <pxPortInitialiseStack+0x1c>)
 8001524:	3b04      	subs	r3, #4
 8001526:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8001528:	3b14      	subs	r3, #20
	pxTopOfStack -= 8; /* R11..R4. */
 800152a:	3840      	subs	r0, #64	; 0x40
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 800152c:	601a      	str	r2, [r3, #0]
}
 800152e:	bd10      	pop	{r4, pc}
 8001530:	080014b1 	.word	0x080014b1

08001534 <SVC_Handler>:
}
 8001534:	4770      	bx	lr
	...

08001538 <xPortStartScheduler>:
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8001538:	22ff      	movs	r2, #255	; 0xff
 800153a:	4b12      	ldr	r3, [pc, #72]	; (8001584 <xPortStartScheduler+0x4c>)
 800153c:	0412      	lsls	r2, r2, #16
 800153e:	6819      	ldr	r1, [r3, #0]
{
 8001540:	b570      	push	{r4, r5, r6, lr}
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8001542:	430a      	orrs	r2, r1
 8001544:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 8001546:	22ff      	movs	r2, #255	; 0xff
 8001548:	6819      	ldr	r1, [r3, #0]
   ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
 }
 #endif /* configUSE_TICKLESS_IDLE */

/* Stop and reset the SysTick. */
	portNVIC_SYSTICK_CTRL = 0UL;
 800154a:	2400      	movs	r4, #0
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 800154c:	0612      	lsls	r2, r2, #24
 800154e:	430a      	orrs	r2, r1
	portNVIC_SYSTICK_CURRENT_VALUE = 0UL;

 /* Configure SysTick to interrupt at the requested rate. */
 portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8001550:	21fa      	movs	r1, #250	; 0xfa
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 8001552:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL = 0UL;
 8001554:	4d0c      	ldr	r5, [pc, #48]	; (8001588 <xPortStartScheduler+0x50>)
	portNVIC_SYSTICK_CURRENT_VALUE = 0UL;
 8001556:	4b0d      	ldr	r3, [pc, #52]	; (800158c <xPortStartScheduler+0x54>)
	portNVIC_SYSTICK_CTRL = 0UL;
 8001558:	602c      	str	r4, [r5, #0]
	portNVIC_SYSTICK_CURRENT_VALUE = 0UL;
 800155a:	601c      	str	r4, [r3, #0]
 portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800155c:	4b0c      	ldr	r3, [pc, #48]	; (8001590 <xPortStartScheduler+0x58>)
 800155e:	0089      	lsls	r1, r1, #2
 8001560:	6818      	ldr	r0, [r3, #0]
 8001562:	f7fe fdd1 	bl	8000108 <__udivsi3>
 8001566:	4b0b      	ldr	r3, [pc, #44]	; (8001594 <xPortStartScheduler+0x5c>)
 8001568:	3801      	subs	r0, #1
 800156a:	6018      	str	r0, [r3, #0]
 portNVIC_SYSTICK_CTRL = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 800156c:	2307      	movs	r3, #7
 800156e:	602b      	str	r3, [r5, #0]
	uxCriticalNesting = 0;
 8001570:	4b09      	ldr	r3, [pc, #36]	; (8001598 <xPortStartScheduler+0x60>)
 8001572:	601c      	str	r4, [r3, #0]
	vPortStartFirstTask();
 8001574:	f7ff ffb4 	bl	80014e0 <vPortStartFirstTask>
	vTaskSwitchContext();
 8001578:	f000 fbae 	bl	8001cd8 <vTaskSwitchContext>
	prvTaskExitError();
 800157c:	f7ff ff98 	bl	80014b0 <prvTaskExitError>
}
 8001580:	0020      	movs	r0, r4
 8001582:	bd70      	pop	{r4, r5, r6, pc}
 8001584:	e000ed20 	.word	0xe000ed20
 8001588:	e000e010 	.word	0xe000e010
 800158c:	e000e018 	.word	0xe000e018
 8001590:	20000008 	.word	0x20000008
 8001594:	e000e014 	.word	0xe000e014
 8001598:	20000004 	.word	0x20000004

0800159c <vPortYield>:
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
 800159c:	2280      	movs	r2, #128	; 0x80
 800159e:	4b04      	ldr	r3, [pc, #16]	; (80015b0 <vPortYield+0x14>)
 80015a0:	0552      	lsls	r2, r2, #21
 80015a2:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" ::: "memory" );
 80015a4:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 80015a8:	f3bf 8f6f 	isb	sy
}
 80015ac:	4770      	bx	lr
 80015ae:	46c0      	nop			; (mov r8, r8)
 80015b0:	e000ed04 	.word	0xe000ed04

080015b4 <vPortEnterCritical>:
    portDISABLE_INTERRUPTS();
 80015b4:	b672      	cpsid	i
    uxCriticalNesting++;
 80015b6:	4a04      	ldr	r2, [pc, #16]	; (80015c8 <vPortEnterCritical+0x14>)
 80015b8:	6813      	ldr	r3, [r2, #0]
 80015ba:	3301      	adds	r3, #1
 80015bc:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" ::: "memory" );
 80015be:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 80015c2:	f3bf 8f6f 	isb	sy
}
 80015c6:	4770      	bx	lr
 80015c8:	20000004 	.word	0x20000004

080015cc <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 80015cc:	4a05      	ldr	r2, [pc, #20]	; (80015e4 <vPortExitCritical+0x18>)
 80015ce:	6813      	ldr	r3, [r2, #0]
 80015d0:	2b00      	cmp	r3, #0
 80015d2:	d101      	bne.n	80015d8 <vPortExitCritical+0xc>
 80015d4:	b672      	cpsid	i
 80015d6:	e7fe      	b.n	80015d6 <vPortExitCritical+0xa>
    uxCriticalNesting--;
 80015d8:	3b01      	subs	r3, #1
 80015da:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
 80015dc:	2b00      	cmp	r3, #0
 80015de:	d100      	bne.n	80015e2 <vPortExitCritical+0x16>
        portENABLE_INTERRUPTS();
 80015e0:	b662      	cpsie	i
}
 80015e2:	4770      	bx	lr
 80015e4:	20000004 	.word	0x20000004

080015e8 <ulSetInterruptMaskFromISR>:
	__asm volatile(
 80015e8:	f3ef 8010 	mrs	r0, PRIMASK
 80015ec:	b672      	cpsid	i
 80015ee:	4770      	bx	lr

080015f0 <vClearInterruptMaskFromISR>:
	__asm volatile(
 80015f0:	f380 8810 	msr	PRIMASK, r0
 80015f4:	4770      	bx	lr
	...

08001600 <PendSV_Handler>:
	__asm volatile
 8001600:	f3ef 8009 	mrs	r0, PSP
 8001604:	4b0e      	ldr	r3, [pc, #56]	; (8001640 <pxCurrentTCBConst>)
 8001606:	681a      	ldr	r2, [r3, #0]
 8001608:	3820      	subs	r0, #32
 800160a:	6010      	str	r0, [r2, #0]
 800160c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 800160e:	4644      	mov	r4, r8
 8001610:	464d      	mov	r5, r9
 8001612:	4656      	mov	r6, sl
 8001614:	465f      	mov	r7, fp
 8001616:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 8001618:	b508      	push	{r3, lr}
 800161a:	b672      	cpsid	i
 800161c:	f000 fb5c 	bl	8001cd8 <vTaskSwitchContext>
 8001620:	b662      	cpsie	i
 8001622:	bc0c      	pop	{r2, r3}
 8001624:	6811      	ldr	r1, [r2, #0]
 8001626:	6808      	ldr	r0, [r1, #0]
 8001628:	3010      	adds	r0, #16
 800162a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800162c:	46a0      	mov	r8, r4
 800162e:	46a9      	mov	r9, r5
 8001630:	46b2      	mov	sl, r6
 8001632:	46bb      	mov	fp, r7
 8001634:	f380 8809 	msr	PSP, r0
 8001638:	3820      	subs	r0, #32
 800163a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800163c:	4718      	bx	r3
 800163e:	46c0      	nop			; (mov r8, r8)

08001640 <pxCurrentTCBConst>:
 8001640:	20000c40 	.word	0x20000c40

08001644 <SysTick_Handler>:
{
 8001644:	b510      	push	{r4, lr}
	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
 8001646:	f7ff ffcf 	bl	80015e8 <ulSetInterruptMaskFromISR>
 800164a:	0004      	movs	r4, r0
		if( xTaskIncrementTick() != pdFALSE )
 800164c:	f000 fa44 	bl	8001ad8 <xTaskIncrementTick>
 8001650:	2800      	cmp	r0, #0
 8001652:	d003      	beq.n	800165c <SysTick_Handler+0x18>
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8001654:	2280      	movs	r2, #128	; 0x80
 8001656:	4b03      	ldr	r3, [pc, #12]	; (8001664 <SysTick_Handler+0x20>)
 8001658:	0552      	lsls	r2, r2, #21
 800165a:	601a      	str	r2, [r3, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
 800165c:	0020      	movs	r0, r4
 800165e:	f7ff ffc7 	bl	80015f0 <vClearInterruptMaskFromISR>
}
 8001662:	bd10      	pop	{r4, pc}
 8001664:	e000ed04 	.word	0xe000ed04

08001668 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8001668:	b510      	push	{r4, lr}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800166a:	4b0f      	ldr	r3, [pc, #60]	; (80016a8 <prvInsertBlockIntoFreeList+0x40>)
 800166c:	681a      	ldr	r2, [r3, #0]
 800166e:	4282      	cmp	r2, r0
 8001670:	d318      	bcc.n	80016a4 <prvInsertBlockIntoFreeList+0x3c>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8001672:	685c      	ldr	r4, [r3, #4]
 8001674:	1919      	adds	r1, r3, r4
 8001676:	4288      	cmp	r0, r1
 8001678:	d103      	bne.n	8001682 <prvInsertBlockIntoFreeList+0x1a>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800167a:	6841      	ldr	r1, [r0, #4]
 800167c:	0018      	movs	r0, r3
 800167e:	1909      	adds	r1, r1, r4
 8001680:	6059      	str	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8001682:	6841      	ldr	r1, [r0, #4]
 8001684:	1844      	adds	r4, r0, r1
 8001686:	42a2      	cmp	r2, r4
 8001688:	d107      	bne.n	800169a <prvInsertBlockIntoFreeList+0x32>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800168a:	4c08      	ldr	r4, [pc, #32]	; (80016ac <prvInsertBlockIntoFreeList+0x44>)
 800168c:	6824      	ldr	r4, [r4, #0]
 800168e:	42a2      	cmp	r2, r4
 8001690:	d003      	beq.n	800169a <prvInsertBlockIntoFreeList+0x32>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8001692:	6854      	ldr	r4, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8001694:	6812      	ldr	r2, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8001696:	1861      	adds	r1, r4, r1
 8001698:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 800169a:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 800169c:	4298      	cmp	r0, r3
 800169e:	d000      	beq.n	80016a2 <prvInsertBlockIntoFreeList+0x3a>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 80016a0:	6018      	str	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 80016a2:	bd10      	pop	{r4, pc}
 80016a4:	0013      	movs	r3, r2
 80016a6:	e7e1      	b.n	800166c <prvInsertBlockIntoFreeList+0x4>
 80016a8:	20000c38 	.word	0x20000c38
 80016ac:	20000028 	.word	0x20000028

080016b0 <pvPortMalloc>:
{
 80016b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80016b2:	0004      	movs	r4, r0
	vTaskSuspendAll();
 80016b4:	f000 fa08 	bl	8001ac8 <vTaskSuspendAll>
		if( pxEnd == NULL )
 80016b8:	4a38      	ldr	r2, [pc, #224]	; (800179c <pvPortMalloc+0xec>)
 80016ba:	4839      	ldr	r0, [pc, #228]	; (80017a0 <pvPortMalloc+0xf0>)
 80016bc:	6813      	ldr	r3, [r2, #0]
 80016be:	2b00      	cmp	r3, #0
 80016c0:	d11e      	bne.n	8001700 <pvPortMalloc+0x50>
	uxAddress = ( size_t ) ucHeap;
 80016c2:	4938      	ldr	r1, [pc, #224]	; (80017a4 <pvPortMalloc+0xf4>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 80016c4:	3307      	adds	r3, #7
 80016c6:	4219      	tst	r1, r3
 80016c8:	d036      	beq.n	8001738 <pvPortMalloc+0x88>
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 80016ca:	18cd      	adds	r5, r1, r3
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80016cc:	439d      	bics	r5, r3
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 80016ce:	23c0      	movs	r3, #192	; 0xc0
 80016d0:	011b      	lsls	r3, r3, #4
 80016d2:	18c9      	adds	r1, r1, r3
 80016d4:	1b4b      	subs	r3, r1, r5
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80016d6:	0029      	movs	r1, r5
	xStart.xBlockSize = ( size_t ) 0;
 80016d8:	2500      	movs	r5, #0
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 80016da:	4e33      	ldr	r6, [pc, #204]	; (80017a8 <pvPortMalloc+0xf8>)
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 80016dc:	18cb      	adds	r3, r1, r3
	xStart.xBlockSize = ( size_t ) 0;
 80016de:	6075      	str	r5, [r6, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 80016e0:	6031      	str	r1, [r6, #0]
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80016e2:	2607      	movs	r6, #7
	uxAddress -= xHeapStructSize;
 80016e4:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80016e6:	43b3      	bics	r3, r6
	pxEnd->pxNextFreeBlock = NULL;
 80016e8:	601d      	str	r5, [r3, #0]
	pxEnd->xBlockSize = 0;
 80016ea:	605d      	str	r5, [r3, #4]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 80016ec:	1a5d      	subs	r5, r3, r1
	pxEnd = ( void * ) uxAddress;
 80016ee:	6013      	str	r3, [r2, #0]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 80016f0:	c128      	stmia	r1!, {r3, r5}
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80016f2:	4b2e      	ldr	r3, [pc, #184]	; (80017ac <pvPortMalloc+0xfc>)
 80016f4:	601d      	str	r5, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80016f6:	4b2e      	ldr	r3, [pc, #184]	; (80017b0 <pvPortMalloc+0x100>)
 80016f8:	601d      	str	r5, [r3, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 80016fa:	2380      	movs	r3, #128	; 0x80
 80016fc:	061b      	lsls	r3, r3, #24
 80016fe:	6003      	str	r3, [r0, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8001700:	6806      	ldr	r6, [r0, #0]
 8001702:	4234      	tst	r4, r6
 8001704:	d116      	bne.n	8001734 <pvPortMalloc+0x84>
			if( xWantedSize > 0 )
 8001706:	2c00      	cmp	r4, #0
 8001708:	d014      	beq.n	8001734 <pvPortMalloc+0x84>
				xWantedSize += xHeapStructSize;
 800170a:	0023      	movs	r3, r4
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800170c:	2107      	movs	r1, #7
				xWantedSize += xHeapStructSize;
 800170e:	3308      	adds	r3, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8001710:	420b      	tst	r3, r1
 8001712:	d001      	beq.n	8001718 <pvPortMalloc+0x68>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8001714:	438b      	bics	r3, r1
 8001716:	3308      	adds	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8001718:	2b00      	cmp	r3, #0
 800171a:	d00b      	beq.n	8001734 <pvPortMalloc+0x84>
 800171c:	4924      	ldr	r1, [pc, #144]	; (80017b0 <pvPortMalloc+0x100>)
 800171e:	680d      	ldr	r5, [r1, #0]
 8001720:	42ab      	cmp	r3, r5
 8001722:	d807      	bhi.n	8001734 <pvPortMalloc+0x84>
				pxBlock = xStart.pxNextFreeBlock;
 8001724:	4920      	ldr	r1, [pc, #128]	; (80017a8 <pvPortMalloc+0xf8>)
 8001726:	680c      	ldr	r4, [r1, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8001728:	6860      	ldr	r0, [r4, #4]
 800172a:	4283      	cmp	r3, r0
 800172c:	d807      	bhi.n	800173e <pvPortMalloc+0x8e>
				if( pxBlock != pxEnd )
 800172e:	6812      	ldr	r2, [r2, #0]
 8001730:	4294      	cmp	r4, r2
 8001732:	d10b      	bne.n	800174c <pvPortMalloc+0x9c>
void *pvReturn = NULL;
 8001734:	2500      	movs	r5, #0
 8001736:	e028      	b.n	800178a <pvPortMalloc+0xda>
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 8001738:	23c0      	movs	r3, #192	; 0xc0
 800173a:	011b      	lsls	r3, r3, #4
 800173c:	e7cc      	b.n	80016d8 <pvPortMalloc+0x28>
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800173e:	6827      	ldr	r7, [r4, #0]
 8001740:	46bc      	mov	ip, r7
 8001742:	2f00      	cmp	r7, #0
 8001744:	d0f3      	beq.n	800172e <pvPortMalloc+0x7e>
 8001746:	0021      	movs	r1, r4
 8001748:	4664      	mov	r4, ip
 800174a:	e7ed      	b.n	8001728 <pvPortMalloc+0x78>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800174c:	680a      	ldr	r2, [r1, #0]
 800174e:	0017      	movs	r7, r2
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8001750:	6822      	ldr	r2, [r4, #0]
 8001752:	600a      	str	r2, [r1, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8001754:	1ac2      	subs	r2, r0, r3
 8001756:	2a10      	cmp	r2, #16
 8001758:	d908      	bls.n	800176c <pvPortMalloc+0xbc>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 800175a:	18e0      	adds	r0, r4, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 800175c:	0741      	lsls	r1, r0, #29
 800175e:	d001      	beq.n	8001764 <pvPortMalloc+0xb4>
 8001760:	b672      	cpsid	i
 8001762:	e7fe      	b.n	8001762 <pvPortMalloc+0xb2>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8001764:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8001766:	6063      	str	r3, [r4, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 8001768:	f7ff ff7e 	bl	8001668 <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800176c:	6863      	ldr	r3, [r4, #4]
 800176e:	4a10      	ldr	r2, [pc, #64]	; (80017b0 <pvPortMalloc+0x100>)
 8001770:	1aed      	subs	r5, r5, r3
 8001772:	6015      	str	r5, [r2, #0]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8001774:	4a0d      	ldr	r2, [pc, #52]	; (80017ac <pvPortMalloc+0xfc>)
 8001776:	6811      	ldr	r1, [r2, #0]
 8001778:	428d      	cmp	r5, r1
 800177a:	d200      	bcs.n	800177e <pvPortMalloc+0xce>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 800177c:	6015      	str	r5, [r2, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800177e:	431e      	orrs	r6, r3
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8001780:	003d      	movs	r5, r7
					pxBlock->pxNextFreeBlock = NULL;
 8001782:	2300      	movs	r3, #0
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8001784:	3508      	adds	r5, #8
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8001786:	6066      	str	r6, [r4, #4]
					pxBlock->pxNextFreeBlock = NULL;
 8001788:	6023      	str	r3, [r4, #0]
	( void ) xTaskResumeAll();
 800178a:	f000 fa23 	bl	8001bd4 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 800178e:	076b      	lsls	r3, r5, #29
 8001790:	d001      	beq.n	8001796 <pvPortMalloc+0xe6>
 8001792:	b672      	cpsid	i
 8001794:	e7fe      	b.n	8001794 <pvPortMalloc+0xe4>
}
 8001796:	0028      	movs	r0, r5
 8001798:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800179a:	46c0      	nop			; (mov r8, r8)
 800179c:	20000028 	.word	0x20000028
 80017a0:	20000c2c 	.word	0x20000c2c
 80017a4:	2000002c 	.word	0x2000002c
 80017a8:	20000c38 	.word	0x20000c38
 80017ac:	20000c34 	.word	0x20000c34
 80017b0:	20000c30 	.word	0x20000c30

080017b4 <vPortFree>:
{
 80017b4:	b510      	push	{r4, lr}
	if( pv != NULL )
 80017b6:	2800      	cmp	r0, #0
 80017b8:	d01b      	beq.n	80017f2 <vPortFree+0x3e>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 80017ba:	4a0e      	ldr	r2, [pc, #56]	; (80017f4 <vPortFree+0x40>)
 80017bc:	3808      	subs	r0, #8
 80017be:	6843      	ldr	r3, [r0, #4]
 80017c0:	6812      	ldr	r2, [r2, #0]
 80017c2:	0004      	movs	r4, r0
 80017c4:	421a      	tst	r2, r3
 80017c6:	d101      	bne.n	80017cc <vPortFree+0x18>
 80017c8:	b672      	cpsid	i
 80017ca:	e7fe      	b.n	80017ca <vPortFree+0x16>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 80017cc:	6801      	ldr	r1, [r0, #0]
 80017ce:	2900      	cmp	r1, #0
 80017d0:	d001      	beq.n	80017d6 <vPortFree+0x22>
 80017d2:	b672      	cpsid	i
 80017d4:	e7fe      	b.n	80017d4 <vPortFree+0x20>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 80017d6:	4393      	bics	r3, r2
 80017d8:	6043      	str	r3, [r0, #4]
				vTaskSuspendAll();
 80017da:	f000 f975 	bl	8001ac8 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 80017de:	4a06      	ldr	r2, [pc, #24]	; (80017f8 <vPortFree+0x44>)
 80017e0:	6863      	ldr	r3, [r4, #4]
 80017e2:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 80017e4:	0020      	movs	r0, r4
					xFreeBytesRemaining += pxLink->xBlockSize;
 80017e6:	185b      	adds	r3, r3, r1
 80017e8:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 80017ea:	f7ff ff3d 	bl	8001668 <prvInsertBlockIntoFreeList>
				( void ) xTaskResumeAll();
 80017ee:	f000 f9f1 	bl	8001bd4 <xTaskResumeAll>
}
 80017f2:	bd10      	pop	{r4, pc}
 80017f4:	20000c2c 	.word	0x20000c2c
 80017f8:	20000c30 	.word	0x20000c30

080017fc <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80017fc:	4a07      	ldr	r2, [pc, #28]	; (800181c <prvResetNextTaskUnblockTime+0x20>)
 80017fe:	6813      	ldr	r3, [r2, #0]
 8001800:	6819      	ldr	r1, [r3, #0]
 8001802:	4b07      	ldr	r3, [pc, #28]	; (8001820 <prvResetNextTaskUnblockTime+0x24>)
 8001804:	2900      	cmp	r1, #0
 8001806:	d103      	bne.n	8001810 <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8001808:	2201      	movs	r2, #1
 800180a:	4252      	negs	r2, r2
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800180c:	601a      	str	r2, [r3, #0]
	}
}
 800180e:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8001810:	6812      	ldr	r2, [r2, #0]
 8001812:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8001814:	68d2      	ldr	r2, [r2, #12]
 8001816:	6852      	ldr	r2, [r2, #4]
 8001818:	e7f8      	b.n	800180c <prvResetNextTaskUnblockTime+0x10>
 800181a:	46c0      	nop			; (mov r8, r8)
 800181c:	20000c44 	.word	0x20000c44
 8001820:	20000d1c 	.word	0x20000d1c

08001824 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8001824:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001826:	0004      	movs	r4, r0
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8001828:	4b14      	ldr	r3, [pc, #80]	; (800187c <prvAddCurrentTaskToDelayedList+0x58>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800182a:	4d15      	ldr	r5, [pc, #84]	; (8001880 <prvAddCurrentTaskToDelayedList+0x5c>)
const TickType_t xConstTickCount = xTickCount;
 800182c:	681e      	ldr	r6, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800182e:	6828      	ldr	r0, [r5, #0]
{
 8001830:	000f      	movs	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8001832:	3004      	adds	r0, #4
 8001834:	f7ff fe2a 	bl	800148c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8001838:	1c63      	adds	r3, r4, #1
 800183a:	d107      	bne.n	800184c <prvAddCurrentTaskToDelayedList+0x28>
 800183c:	2f00      	cmp	r7, #0
 800183e:	d005      	beq.n	800184c <prvAddCurrentTaskToDelayedList+0x28>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001840:	6829      	ldr	r1, [r5, #0]
 8001842:	4810      	ldr	r0, [pc, #64]	; (8001884 <prvAddCurrentTaskToDelayedList+0x60>)
 8001844:	3104      	adds	r1, #4
 8001846:	f7ff fdfe 	bl	8001446 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 800184a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 800184c:	682b      	ldr	r3, [r5, #0]
			xTimeToWake = xConstTickCount + xTicksToWait;
 800184e:	1934      	adds	r4, r6, r4
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8001850:	605c      	str	r4, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 8001852:	42a6      	cmp	r6, r4
 8001854:	d906      	bls.n	8001864 <prvAddCurrentTaskToDelayedList+0x40>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001856:	4b0c      	ldr	r3, [pc, #48]	; (8001888 <prvAddCurrentTaskToDelayedList+0x64>)
 8001858:	6818      	ldr	r0, [r3, #0]
 800185a:	6829      	ldr	r1, [r5, #0]
 800185c:	3104      	adds	r1, #4
 800185e:	f7ff fdfe 	bl	800145e <vListInsert>
 8001862:	e7f2      	b.n	800184a <prvAddCurrentTaskToDelayedList+0x26>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001864:	4b09      	ldr	r3, [pc, #36]	; (800188c <prvAddCurrentTaskToDelayedList+0x68>)
 8001866:	6818      	ldr	r0, [r3, #0]
 8001868:	6829      	ldr	r1, [r5, #0]
 800186a:	3104      	adds	r1, #4
 800186c:	f7ff fdf7 	bl	800145e <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8001870:	4b07      	ldr	r3, [pc, #28]	; (8001890 <prvAddCurrentTaskToDelayedList+0x6c>)
 8001872:	681a      	ldr	r2, [r3, #0]
 8001874:	4294      	cmp	r4, r2
 8001876:	d2e8      	bcs.n	800184a <prvAddCurrentTaskToDelayedList+0x26>
					xNextTaskUnblockTime = xTimeToWake;
 8001878:	601c      	str	r4, [r3, #0]
}
 800187a:	e7e6      	b.n	800184a <prvAddCurrentTaskToDelayedList+0x26>
 800187c:	20000d64 	.word	0x20000d64
 8001880:	20000c40 	.word	0x20000c40
 8001884:	20000d3c 	.word	0x20000d3c
 8001888:	20000c48 	.word	0x20000c48
 800188c:	20000c44 	.word	0x20000c44
 8001890:	20000d1c 	.word	0x20000d1c

08001894 <prvIdleTask>:
{
 8001894:	b570      	push	{r4, r5, r6, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8001896:	4c11      	ldr	r4, [pc, #68]	; (80018dc <prvIdleTask+0x48>)
 8001898:	6823      	ldr	r3, [r4, #0]
 800189a:	2b00      	cmp	r3, #0
 800189c:	d106      	bne.n	80018ac <prvIdleTask+0x18>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 800189e:	4b10      	ldr	r3, [pc, #64]	; (80018e0 <prvIdleTask+0x4c>)
 80018a0:	681b      	ldr	r3, [r3, #0]
 80018a2:	2b01      	cmp	r3, #1
 80018a4:	d9f7      	bls.n	8001896 <prvIdleTask+0x2>
				taskYIELD();
 80018a6:	f7ff fe79 	bl	800159c <vPortYield>
 80018aa:	e7f4      	b.n	8001896 <prvIdleTask+0x2>
			taskENTER_CRITICAL();
 80018ac:	f7ff fe82 	bl	80015b4 <vPortEnterCritical>
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 80018b0:	4b0c      	ldr	r3, [pc, #48]	; (80018e4 <prvIdleTask+0x50>)
 80018b2:	68db      	ldr	r3, [r3, #12]
 80018b4:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80018b6:	1d28      	adds	r0, r5, #4
 80018b8:	f7ff fde8 	bl	800148c <uxListRemove>
				--uxCurrentNumberOfTasks;
 80018bc:	4a0a      	ldr	r2, [pc, #40]	; (80018e8 <prvIdleTask+0x54>)
 80018be:	6813      	ldr	r3, [r2, #0]
 80018c0:	3b01      	subs	r3, #1
 80018c2:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
 80018c4:	6823      	ldr	r3, [r4, #0]
 80018c6:	3b01      	subs	r3, #1
 80018c8:	6023      	str	r3, [r4, #0]
			taskEXIT_CRITICAL();
 80018ca:	f7ff fe7f 	bl	80015cc <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
 80018ce:	6b28      	ldr	r0, [r5, #48]	; 0x30
 80018d0:	f7ff ff70 	bl	80017b4 <vPortFree>
			vPortFree( pxTCB );
 80018d4:	0028      	movs	r0, r5
 80018d6:	f7ff ff6d 	bl	80017b4 <vPortFree>
 80018da:	e7dc      	b.n	8001896 <prvIdleTask+0x2>
 80018dc:	20000cdc 	.word	0x20000cdc
 80018e0:	20000c4c 	.word	0x20000c4c
 80018e4:	20000d50 	.word	0x20000d50
 80018e8:	20000cd8 	.word	0x20000cd8

080018ec <xTaskCreate>:
	{
 80018ec:	b5f0      	push	{r4, r5, r6, r7, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80018ee:	0095      	lsls	r5, r2, #2
	{
 80018f0:	b085      	sub	sp, #20
 80018f2:	9002      	str	r0, [sp, #8]
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80018f4:	0028      	movs	r0, r5
	{
 80018f6:	000f      	movs	r7, r1
 80018f8:	9303      	str	r3, [sp, #12]
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80018fa:	f7ff fed9 	bl	80016b0 <pvPortMalloc>
 80018fe:	1e06      	subs	r6, r0, #0
			if( pxStack != NULL )
 8001900:	d100      	bne.n	8001904 <xTaskCreate+0x18>
 8001902:	e08e      	b.n	8001a22 <xTaskCreate+0x136>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 8001904:	2054      	movs	r0, #84	; 0x54
 8001906:	f7ff fed3 	bl	80016b0 <pvPortMalloc>
 800190a:	1e04      	subs	r4, r0, #0
				if( pxNewTCB != NULL )
 800190c:	d100      	bne.n	8001910 <xTaskCreate+0x24>
 800190e:	e085      	b.n	8001a1c <xTaskCreate+0x130>
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8001910:	2307      	movs	r3, #7
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8001912:	3d04      	subs	r5, #4
					pxNewTCB->pxStack = pxStack;
 8001914:	6306      	str	r6, [r0, #48]	; 0x30
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8001916:	1976      	adds	r6, r6, r5
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8001918:	439e      	bics	r6, r3
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800191a:	2300      	movs	r3, #0
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800191c:	9600      	str	r6, [sp, #0]
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800191e:	001a      	movs	r2, r3
 8001920:	5cf9      	ldrb	r1, [r7, r3]
 8001922:	3234      	adds	r2, #52	; 0x34
 8001924:	54a1      	strb	r1, [r4, r2]
		if( pcName[ x ] == 0x00 )
 8001926:	5cfa      	ldrb	r2, [r7, r3]
 8001928:	2a00      	cmp	r2, #0
 800192a:	d002      	beq.n	8001932 <xTaskCreate+0x46>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800192c:	3301      	adds	r3, #1
 800192e:	2b10      	cmp	r3, #16
 8001930:	d1f5      	bne.n	800191e <xTaskCreate+0x32>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8001932:	0023      	movs	r3, r4
 8001934:	2500      	movs	r5, #0
 8001936:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 8001938:	3343      	adds	r3, #67	; 0x43
 800193a:	701d      	strb	r5, [r3, #0]
 800193c:	2e06      	cmp	r6, #6
 800193e:	d900      	bls.n	8001942 <xTaskCreate+0x56>
 8001940:	2606      	movs	r6, #6
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8001942:	1d23      	adds	r3, r4, #4
 8001944:	0018      	movs	r0, r3
	pxNewTCB->uxPriority = uxPriority;
 8001946:	62e6      	str	r6, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 8001948:	6466      	str	r6, [r4, #68]	; 0x44
		pxNewTCB->uxMutexesHeld = 0;
 800194a:	64a5      	str	r5, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800194c:	9301      	str	r3, [sp, #4]
 800194e:	f7ff fd77 	bl	8001440 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8001952:	0020      	movs	r0, r4
 8001954:	3018      	adds	r0, #24
 8001956:	f7ff fd73 	bl	8001440 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800195a:	2307      	movs	r3, #7
 800195c:	1b9e      	subs	r6, r3, r6
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800195e:	0023      	movs	r3, r4
 8001960:	3350      	adds	r3, #80	; 0x50
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8001962:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001964:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8001966:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
 8001968:	64e5      	str	r5, [r4, #76]	; 0x4c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800196a:	9a03      	ldr	r2, [sp, #12]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800196c:	701d      	strb	r5, [r3, #0]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800196e:	9902      	ldr	r1, [sp, #8]
 8001970:	9800      	ldr	r0, [sp, #0]
 8001972:	f7ff fdcf 	bl	8001514 <pxPortInitialiseStack>
	if( ( void * ) pxCreatedTask != NULL )
 8001976:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8001978:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 800197a:	2b00      	cmp	r3, #0
 800197c:	d000      	beq.n	8001980 <xTaskCreate+0x94>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 800197e:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
 8001980:	f7ff fe18 	bl	80015b4 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8001984:	4b2e      	ldr	r3, [pc, #184]	; (8001a40 <xTaskCreate+0x154>)
		if( pxCurrentTCB == NULL )
 8001986:	4d2f      	ldr	r5, [pc, #188]	; (8001a44 <xTaskCreate+0x158>)
		uxCurrentNumberOfTasks++;
 8001988:	681a      	ldr	r2, [r3, #0]
 800198a:	3201      	adds	r2, #1
 800198c:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
 800198e:	682a      	ldr	r2, [r5, #0]
 8001990:	2a00      	cmp	r2, #0
 8001992:	d149      	bne.n	8001a28 <xTaskCreate+0x13c>
			pxCurrentTCB = pxNewTCB;
 8001994:	602c      	str	r4, [r5, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8001996:	681b      	ldr	r3, [r3, #0]
 8001998:	2b01      	cmp	r3, #1
 800199a:	d11d      	bne.n	80019d8 <xTaskCreate+0xec>
 800199c:	4e2a      	ldr	r6, [pc, #168]	; (8001a48 <xTaskCreate+0x15c>)
 800199e:	0037      	movs	r7, r6
 80019a0:	378c      	adds	r7, #140	; 0x8c
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 80019a2:	0030      	movs	r0, r6
 80019a4:	3614      	adds	r6, #20
 80019a6:	f7ff fd40 	bl	800142a <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 80019aa:	42b7      	cmp	r7, r6
 80019ac:	d1f9      	bne.n	80019a2 <xTaskCreate+0xb6>
	vListInitialise( &xDelayedTaskList1 );
 80019ae:	4e27      	ldr	r6, [pc, #156]	; (8001a4c <xTaskCreate+0x160>)
 80019b0:	0030      	movs	r0, r6
 80019b2:	f7ff fd3a 	bl	800142a <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 80019b6:	4f26      	ldr	r7, [pc, #152]	; (8001a50 <xTaskCreate+0x164>)
 80019b8:	0038      	movs	r0, r7
 80019ba:	f7ff fd36 	bl	800142a <vListInitialise>
	vListInitialise( &xPendingReadyList );
 80019be:	4825      	ldr	r0, [pc, #148]	; (8001a54 <xTaskCreate+0x168>)
 80019c0:	f7ff fd33 	bl	800142a <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 80019c4:	4824      	ldr	r0, [pc, #144]	; (8001a58 <xTaskCreate+0x16c>)
 80019c6:	f7ff fd30 	bl	800142a <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 80019ca:	4824      	ldr	r0, [pc, #144]	; (8001a5c <xTaskCreate+0x170>)
 80019cc:	f7ff fd2d 	bl	800142a <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 80019d0:	4b23      	ldr	r3, [pc, #140]	; (8001a60 <xTaskCreate+0x174>)
 80019d2:	601e      	str	r6, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80019d4:	4b23      	ldr	r3, [pc, #140]	; (8001a64 <xTaskCreate+0x178>)
 80019d6:	601f      	str	r7, [r3, #0]
		uxTaskNumber++;
 80019d8:	4a23      	ldr	r2, [pc, #140]	; (8001a68 <xTaskCreate+0x17c>)
 80019da:	6813      	ldr	r3, [r2, #0]
 80019dc:	3301      	adds	r3, #1
 80019de:	6013      	str	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 80019e0:	4a22      	ldr	r2, [pc, #136]	; (8001a6c <xTaskCreate+0x180>)
 80019e2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80019e4:	6811      	ldr	r1, [r2, #0]
 80019e6:	428b      	cmp	r3, r1
 80019e8:	d900      	bls.n	80019ec <xTaskCreate+0x100>
 80019ea:	6013      	str	r3, [r2, #0]
 80019ec:	2014      	movs	r0, #20
 80019ee:	4358      	muls	r0, r3
 80019f0:	4b15      	ldr	r3, [pc, #84]	; (8001a48 <xTaskCreate+0x15c>)
 80019f2:	9901      	ldr	r1, [sp, #4]
 80019f4:	1818      	adds	r0, r3, r0
 80019f6:	f7ff fd26 	bl	8001446 <vListInsertEnd>
	taskEXIT_CRITICAL();
 80019fa:	f7ff fde7 	bl	80015cc <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 80019fe:	4b1c      	ldr	r3, [pc, #112]	; (8001a70 <xTaskCreate+0x184>)
			xReturn = pdPASS;
 8001a00:	2601      	movs	r6, #1
	if( xSchedulerRunning != pdFALSE )
 8001a02:	681b      	ldr	r3, [r3, #0]
 8001a04:	2b00      	cmp	r3, #0
 8001a06:	d006      	beq.n	8001a16 <xTaskCreate+0x12a>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8001a08:	682b      	ldr	r3, [r5, #0]
 8001a0a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001a0c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001a0e:	429a      	cmp	r2, r3
 8001a10:	d201      	bcs.n	8001a16 <xTaskCreate+0x12a>
			taskYIELD_IF_USING_PREEMPTION();
 8001a12:	f7ff fdc3 	bl	800159c <vPortYield>
	}
 8001a16:	0030      	movs	r0, r6
 8001a18:	b005      	add	sp, #20
 8001a1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
					vPortFree( pxStack );
 8001a1c:	0030      	movs	r0, r6
 8001a1e:	f7ff fec9 	bl	80017b4 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8001a22:	2601      	movs	r6, #1
 8001a24:	4276      	negs	r6, r6
 8001a26:	e7f6      	b.n	8001a16 <xTaskCreate+0x12a>
			if( xSchedulerRunning == pdFALSE )
 8001a28:	4b11      	ldr	r3, [pc, #68]	; (8001a70 <xTaskCreate+0x184>)
 8001a2a:	681b      	ldr	r3, [r3, #0]
 8001a2c:	2b00      	cmp	r3, #0
 8001a2e:	d1d3      	bne.n	80019d8 <xTaskCreate+0xec>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8001a30:	682b      	ldr	r3, [r5, #0]
 8001a32:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001a34:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001a36:	4293      	cmp	r3, r2
 8001a38:	d8ce      	bhi.n	80019d8 <xTaskCreate+0xec>
					pxCurrentTCB = pxNewTCB;
 8001a3a:	602c      	str	r4, [r5, #0]
 8001a3c:	e7cc      	b.n	80019d8 <xTaskCreate+0xec>
 8001a3e:	46c0      	nop			; (mov r8, r8)
 8001a40:	20000cd8 	.word	0x20000cd8
 8001a44:	20000c40 	.word	0x20000c40
 8001a48:	20000c4c 	.word	0x20000c4c
 8001a4c:	20000cf0 	.word	0x20000cf0
 8001a50:	20000d04 	.word	0x20000d04
 8001a54:	20000d24 	.word	0x20000d24
 8001a58:	20000d50 	.word	0x20000d50
 8001a5c:	20000d3c 	.word	0x20000d3c
 8001a60:	20000c44 	.word	0x20000c44
 8001a64:	20000c48 	.word	0x20000c48
 8001a68:	20000ce8 	.word	0x20000ce8
 8001a6c:	20000cec 	.word	0x20000cec
 8001a70:	20000d38 	.word	0x20000d38

08001a74 <vTaskStartScheduler>:
{
 8001a74:	b513      	push	{r0, r1, r4, lr}
		xReturn = xTaskCreate(	prvIdleTask,
 8001a76:	2400      	movs	r4, #0
 8001a78:	4b0d      	ldr	r3, [pc, #52]	; (8001ab0 <vTaskStartScheduler+0x3c>)
 8001a7a:	9400      	str	r4, [sp, #0]
 8001a7c:	9301      	str	r3, [sp, #4]
 8001a7e:	2280      	movs	r2, #128	; 0x80
 8001a80:	0023      	movs	r3, r4
 8001a82:	490c      	ldr	r1, [pc, #48]	; (8001ab4 <vTaskStartScheduler+0x40>)
 8001a84:	480c      	ldr	r0, [pc, #48]	; (8001ab8 <vTaskStartScheduler+0x44>)
 8001a86:	f7ff ff31 	bl	80018ec <xTaskCreate>
	if( xReturn == pdPASS )
 8001a8a:	2801      	cmp	r0, #1
 8001a8c:	d10b      	bne.n	8001aa6 <vTaskStartScheduler+0x32>
		portDISABLE_INTERRUPTS();
 8001a8e:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
 8001a90:	2201      	movs	r2, #1
 8001a92:	4b0a      	ldr	r3, [pc, #40]	; (8001abc <vTaskStartScheduler+0x48>)
 8001a94:	4252      	negs	r2, r2
 8001a96:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 8001a98:	4b09      	ldr	r3, [pc, #36]	; (8001ac0 <vTaskStartScheduler+0x4c>)
 8001a9a:	6018      	str	r0, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 8001a9c:	4b09      	ldr	r3, [pc, #36]	; (8001ac4 <vTaskStartScheduler+0x50>)
 8001a9e:	601c      	str	r4, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
 8001aa0:	f7ff fd4a 	bl	8001538 <xPortStartScheduler>
}
 8001aa4:	bd13      	pop	{r0, r1, r4, pc}
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8001aa6:	1c43      	adds	r3, r0, #1
 8001aa8:	d1fc      	bne.n	8001aa4 <vTaskStartScheduler+0x30>
 8001aaa:	b672      	cpsid	i
 8001aac:	e7fe      	b.n	8001aac <vTaskStartScheduler+0x38>
 8001aae:	46c0      	nop			; (mov r8, r8)
 8001ab0:	20000d18 	.word	0x20000d18
 8001ab4:	080021d0 	.word	0x080021d0
 8001ab8:	08001895 	.word	0x08001895
 8001abc:	20000d1c 	.word	0x20000d1c
 8001ac0:	20000d38 	.word	0x20000d38
 8001ac4:	20000d64 	.word	0x20000d64

08001ac8 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8001ac8:	4a02      	ldr	r2, [pc, #8]	; (8001ad4 <vTaskSuspendAll+0xc>)
 8001aca:	6813      	ldr	r3, [r2, #0]
 8001acc:	3301      	adds	r3, #1
 8001ace:	6013      	str	r3, [r2, #0]
}
 8001ad0:	4770      	bx	lr
 8001ad2:	46c0      	nop			; (mov r8, r8)
 8001ad4:	20000ce4 	.word	0x20000ce4

08001ad8 <xTaskIncrementTick>:
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001ad8:	4b33      	ldr	r3, [pc, #204]	; (8001ba8 <xTaskIncrementTick+0xd0>)
{
 8001ada:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001adc:	681b      	ldr	r3, [r3, #0]
 8001ade:	2b00      	cmp	r3, #0
 8001ae0:	d135      	bne.n	8001b4e <xTaskIncrementTick+0x76>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8001ae2:	4b32      	ldr	r3, [pc, #200]	; (8001bac <xTaskIncrementTick+0xd4>)
 8001ae4:	681c      	ldr	r4, [r3, #0]
 8001ae6:	3401      	adds	r4, #1
		xTickCount = xConstTickCount;
 8001ae8:	601c      	str	r4, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8001aea:	2c00      	cmp	r4, #0
 8001aec:	d111      	bne.n	8001b12 <xTaskIncrementTick+0x3a>
			taskSWITCH_DELAYED_LISTS();
 8001aee:	4b30      	ldr	r3, [pc, #192]	; (8001bb0 <xTaskIncrementTick+0xd8>)
 8001af0:	681a      	ldr	r2, [r3, #0]
 8001af2:	6812      	ldr	r2, [r2, #0]
 8001af4:	2a00      	cmp	r2, #0
 8001af6:	d001      	beq.n	8001afc <xTaskIncrementTick+0x24>
 8001af8:	b672      	cpsid	i
 8001afa:	e7fe      	b.n	8001afa <xTaskIncrementTick+0x22>
 8001afc:	4a2d      	ldr	r2, [pc, #180]	; (8001bb4 <xTaskIncrementTick+0xdc>)
 8001afe:	6819      	ldr	r1, [r3, #0]
 8001b00:	6810      	ldr	r0, [r2, #0]
 8001b02:	6018      	str	r0, [r3, #0]
 8001b04:	6011      	str	r1, [r2, #0]
 8001b06:	4a2c      	ldr	r2, [pc, #176]	; (8001bb8 <xTaskIncrementTick+0xe0>)
 8001b08:	6813      	ldr	r3, [r2, #0]
 8001b0a:	3301      	adds	r3, #1
 8001b0c:	6013      	str	r3, [r2, #0]
 8001b0e:	f7ff fe75 	bl	80017fc <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 8001b12:	4f2a      	ldr	r7, [pc, #168]	; (8001bbc <xTaskIncrementTick+0xe4>)
BaseType_t xSwitchRequired = pdFALSE;
 8001b14:	2600      	movs	r6, #0
		if( xConstTickCount >= xNextTaskUnblockTime )
 8001b16:	683b      	ldr	r3, [r7, #0]
 8001b18:	429c      	cmp	r4, r3
 8001b1a:	d307      	bcc.n	8001b2c <xTaskIncrementTick+0x54>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001b1c:	4b24      	ldr	r3, [pc, #144]	; (8001bb0 <xTaskIncrementTick+0xd8>)
 8001b1e:	681a      	ldr	r2, [r3, #0]
 8001b20:	6812      	ldr	r2, [r2, #0]
 8001b22:	2a00      	cmp	r2, #0
 8001b24:	d119      	bne.n	8001b5a <xTaskIncrementTick+0x82>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001b26:	2301      	movs	r3, #1
 8001b28:	425b      	negs	r3, r3
 8001b2a:	603b      	str	r3, [r7, #0]
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8001b2c:	4b24      	ldr	r3, [pc, #144]	; (8001bc0 <xTaskIncrementTick+0xe8>)
 8001b2e:	681b      	ldr	r3, [r3, #0]
 8001b30:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001b32:	2314      	movs	r3, #20
 8001b34:	4353      	muls	r3, r2
 8001b36:	4a23      	ldr	r2, [pc, #140]	; (8001bc4 <xTaskIncrementTick+0xec>)
 8001b38:	58d3      	ldr	r3, [r2, r3]
 8001b3a:	2b01      	cmp	r3, #1
 8001b3c:	d900      	bls.n	8001b40 <xTaskIncrementTick+0x68>
				xSwitchRequired = pdTRUE;
 8001b3e:	2601      	movs	r6, #1
		if( xYieldPending != pdFALSE )
 8001b40:	4b21      	ldr	r3, [pc, #132]	; (8001bc8 <xTaskIncrementTick+0xf0>)
 8001b42:	681b      	ldr	r3, [r3, #0]
 8001b44:	2b00      	cmp	r3, #0
 8001b46:	d000      	beq.n	8001b4a <xTaskIncrementTick+0x72>
			xSwitchRequired = pdTRUE;
 8001b48:	2601      	movs	r6, #1
}
 8001b4a:	0030      	movs	r0, r6
 8001b4c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		++uxPendedTicks;
 8001b4e:	4a1f      	ldr	r2, [pc, #124]	; (8001bcc <xTaskIncrementTick+0xf4>)
BaseType_t xSwitchRequired = pdFALSE;
 8001b50:	2600      	movs	r6, #0
		++uxPendedTicks;
 8001b52:	6813      	ldr	r3, [r2, #0]
 8001b54:	3301      	adds	r3, #1
 8001b56:	6013      	str	r3, [r2, #0]
 8001b58:	e7f2      	b.n	8001b40 <xTaskIncrementTick+0x68>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8001b5a:	681b      	ldr	r3, [r3, #0]
 8001b5c:	68db      	ldr	r3, [r3, #12]
 8001b5e:	68dd      	ldr	r5, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8001b60:	686b      	ldr	r3, [r5, #4]
					if( xConstTickCount < xItemValue )
 8001b62:	429c      	cmp	r4, r3
 8001b64:	d3e1      	bcc.n	8001b2a <xTaskIncrementTick+0x52>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001b66:	1d2b      	adds	r3, r5, #4
 8001b68:	0018      	movs	r0, r3
 8001b6a:	9301      	str	r3, [sp, #4]
 8001b6c:	f7ff fc8e 	bl	800148c <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8001b70:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8001b72:	2b00      	cmp	r3, #0
 8001b74:	d003      	beq.n	8001b7e <xTaskIncrementTick+0xa6>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001b76:	0028      	movs	r0, r5
 8001b78:	3018      	adds	r0, #24
 8001b7a:	f7ff fc87 	bl	800148c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8001b7e:	4b14      	ldr	r3, [pc, #80]	; (8001bd0 <xTaskIncrementTick+0xf8>)
 8001b80:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8001b82:	681a      	ldr	r2, [r3, #0]
 8001b84:	4290      	cmp	r0, r2
 8001b86:	d900      	bls.n	8001b8a <xTaskIncrementTick+0xb2>
 8001b88:	6018      	str	r0, [r3, #0]
 8001b8a:	2314      	movs	r3, #20
 8001b8c:	4358      	muls	r0, r3
 8001b8e:	4b0d      	ldr	r3, [pc, #52]	; (8001bc4 <xTaskIncrementTick+0xec>)
 8001b90:	1d29      	adds	r1, r5, #4
 8001b92:	1818      	adds	r0, r3, r0
 8001b94:	f7ff fc57 	bl	8001446 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001b98:	4b09      	ldr	r3, [pc, #36]	; (8001bc0 <xTaskIncrementTick+0xe8>)
 8001b9a:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8001b9c:	681b      	ldr	r3, [r3, #0]
 8001b9e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001ba0:	429a      	cmp	r2, r3
 8001ba2:	d3bb      	bcc.n	8001b1c <xTaskIncrementTick+0x44>
							xSwitchRequired = pdTRUE;
 8001ba4:	2601      	movs	r6, #1
 8001ba6:	e7b9      	b.n	8001b1c <xTaskIncrementTick+0x44>
 8001ba8:	20000ce4 	.word	0x20000ce4
 8001bac:	20000d64 	.word	0x20000d64
 8001bb0:	20000c44 	.word	0x20000c44
 8001bb4:	20000c48 	.word	0x20000c48
 8001bb8:	20000d20 	.word	0x20000d20
 8001bbc:	20000d1c 	.word	0x20000d1c
 8001bc0:	20000c40 	.word	0x20000c40
 8001bc4:	20000c4c 	.word	0x20000c4c
 8001bc8:	20000d68 	.word	0x20000d68
 8001bcc:	20000ce0 	.word	0x20000ce0
 8001bd0:	20000cec 	.word	0x20000cec

08001bd4 <xTaskResumeAll>:
{
 8001bd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( uxSchedulerSuspended );
 8001bd6:	4c2b      	ldr	r4, [pc, #172]	; (8001c84 <xTaskResumeAll+0xb0>)
 8001bd8:	6823      	ldr	r3, [r4, #0]
 8001bda:	2b00      	cmp	r3, #0
 8001bdc:	d101      	bne.n	8001be2 <xTaskResumeAll+0xe>
 8001bde:	b672      	cpsid	i
 8001be0:	e7fe      	b.n	8001be0 <xTaskResumeAll+0xc>
	taskENTER_CRITICAL();
 8001be2:	f7ff fce7 	bl	80015b4 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8001be6:	6823      	ldr	r3, [r4, #0]
 8001be8:	3b01      	subs	r3, #1
 8001bea:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001bec:	6824      	ldr	r4, [r4, #0]
 8001bee:	2c00      	cmp	r4, #0
 8001bf0:	d004      	beq.n	8001bfc <xTaskResumeAll+0x28>
BaseType_t xAlreadyYielded = pdFALSE;
 8001bf2:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8001bf4:	f7ff fcea 	bl	80015cc <vPortExitCritical>
}
 8001bf8:	0020      	movs	r0, r4
 8001bfa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8001bfc:	4b22      	ldr	r3, [pc, #136]	; (8001c88 <xTaskResumeAll+0xb4>)
 8001bfe:	681b      	ldr	r3, [r3, #0]
 8001c00:	2b00      	cmp	r3, #0
 8001c02:	d0f6      	beq.n	8001bf2 <xTaskResumeAll+0x1e>
					prvAddTaskToReadyList( pxTCB );
 8001c04:	2614      	movs	r6, #20
						xYieldPending = pdTRUE;
 8001c06:	2701      	movs	r7, #1
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8001c08:	4b20      	ldr	r3, [pc, #128]	; (8001c8c <xTaskResumeAll+0xb8>)
 8001c0a:	681a      	ldr	r2, [r3, #0]
 8001c0c:	2a00      	cmp	r2, #0
 8001c0e:	d11a      	bne.n	8001c46 <xTaskResumeAll+0x72>
				if( pxTCB != NULL )
 8001c10:	2c00      	cmp	r4, #0
 8001c12:	d001      	beq.n	8001c18 <xTaskResumeAll+0x44>
					prvResetNextTaskUnblockTime();
 8001c14:	f7ff fdf2 	bl	80017fc <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 8001c18:	4d1d      	ldr	r5, [pc, #116]	; (8001c90 <xTaskResumeAll+0xbc>)
 8001c1a:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 8001c1c:	2c00      	cmp	r4, #0
 8001c1e:	d00a      	beq.n	8001c36 <xTaskResumeAll+0x62>
								xYieldPending = pdTRUE;
 8001c20:	2601      	movs	r6, #1
							if( xTaskIncrementTick() != pdFALSE )
 8001c22:	f7ff ff59 	bl	8001ad8 <xTaskIncrementTick>
 8001c26:	2800      	cmp	r0, #0
 8001c28:	d001      	beq.n	8001c2e <xTaskResumeAll+0x5a>
								xYieldPending = pdTRUE;
 8001c2a:	4b1a      	ldr	r3, [pc, #104]	; (8001c94 <xTaskResumeAll+0xc0>)
 8001c2c:	601e      	str	r6, [r3, #0]
							--uxPendedCounts;
 8001c2e:	3c01      	subs	r4, #1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 8001c30:	2c00      	cmp	r4, #0
 8001c32:	d1f6      	bne.n	8001c22 <xTaskResumeAll+0x4e>
						uxPendedTicks = 0;
 8001c34:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
 8001c36:	4b17      	ldr	r3, [pc, #92]	; (8001c94 <xTaskResumeAll+0xc0>)
 8001c38:	681b      	ldr	r3, [r3, #0]
 8001c3a:	2b00      	cmp	r3, #0
 8001c3c:	d0d9      	beq.n	8001bf2 <xTaskResumeAll+0x1e>
					taskYIELD_IF_USING_PREEMPTION();
 8001c3e:	f7ff fcad 	bl	800159c <vPortYield>
						xAlreadyYielded = pdTRUE;
 8001c42:	2401      	movs	r4, #1
 8001c44:	e7d6      	b.n	8001bf4 <xTaskResumeAll+0x20>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8001c46:	68db      	ldr	r3, [r3, #12]
 8001c48:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001c4a:	0020      	movs	r0, r4
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001c4c:	1d25      	adds	r5, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001c4e:	3018      	adds	r0, #24
 8001c50:	f7ff fc1c 	bl	800148c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001c54:	0028      	movs	r0, r5
 8001c56:	f7ff fc19 	bl	800148c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8001c5a:	4b0f      	ldr	r3, [pc, #60]	; (8001c98 <xTaskResumeAll+0xc4>)
 8001c5c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8001c5e:	681a      	ldr	r2, [r3, #0]
 8001c60:	4290      	cmp	r0, r2
 8001c62:	d900      	bls.n	8001c66 <xTaskResumeAll+0x92>
 8001c64:	6018      	str	r0, [r3, #0]
 8001c66:	4370      	muls	r0, r6
 8001c68:	4b0c      	ldr	r3, [pc, #48]	; (8001c9c <xTaskResumeAll+0xc8>)
 8001c6a:	0029      	movs	r1, r5
 8001c6c:	1818      	adds	r0, r3, r0
 8001c6e:	f7ff fbea 	bl	8001446 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001c72:	4b0b      	ldr	r3, [pc, #44]	; (8001ca0 <xTaskResumeAll+0xcc>)
 8001c74:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001c76:	681b      	ldr	r3, [r3, #0]
 8001c78:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001c7a:	429a      	cmp	r2, r3
 8001c7c:	d3c4      	bcc.n	8001c08 <xTaskResumeAll+0x34>
						xYieldPending = pdTRUE;
 8001c7e:	4b05      	ldr	r3, [pc, #20]	; (8001c94 <xTaskResumeAll+0xc0>)
 8001c80:	601f      	str	r7, [r3, #0]
 8001c82:	e7c1      	b.n	8001c08 <xTaskResumeAll+0x34>
 8001c84:	20000ce4 	.word	0x20000ce4
 8001c88:	20000cd8 	.word	0x20000cd8
 8001c8c:	20000d24 	.word	0x20000d24
 8001c90:	20000ce0 	.word	0x20000ce0
 8001c94:	20000d68 	.word	0x20000d68
 8001c98:	20000cec 	.word	0x20000cec
 8001c9c:	20000c4c 	.word	0x20000c4c
 8001ca0:	20000c40 	.word	0x20000c40

08001ca4 <vTaskDelay>:
	{
 8001ca4:	b570      	push	{r4, r5, r6, lr}
 8001ca6:	1e04      	subs	r4, r0, #0
		if( xTicksToDelay > ( TickType_t ) 0U )
 8001ca8:	d102      	bne.n	8001cb0 <vTaskDelay+0xc>
			portYIELD_WITHIN_API();
 8001caa:	f7ff fc77 	bl	800159c <vPortYield>
	}
 8001cae:	bd70      	pop	{r4, r5, r6, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 8001cb0:	4b08      	ldr	r3, [pc, #32]	; (8001cd4 <vTaskDelay+0x30>)
 8001cb2:	681d      	ldr	r5, [r3, #0]
 8001cb4:	2d00      	cmp	r5, #0
 8001cb6:	d001      	beq.n	8001cbc <vTaskDelay+0x18>
 8001cb8:	b672      	cpsid	i
 8001cba:	e7fe      	b.n	8001cba <vTaskDelay+0x16>
			vTaskSuspendAll();
 8001cbc:	f7ff ff04 	bl	8001ac8 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8001cc0:	0029      	movs	r1, r5
 8001cc2:	0020      	movs	r0, r4
 8001cc4:	f7ff fdae 	bl	8001824 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 8001cc8:	f7ff ff84 	bl	8001bd4 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 8001ccc:	2800      	cmp	r0, #0
 8001cce:	d1ee      	bne.n	8001cae <vTaskDelay+0xa>
 8001cd0:	e7eb      	b.n	8001caa <vTaskDelay+0x6>
 8001cd2:	46c0      	nop			; (mov r8, r8)
 8001cd4:	20000ce4 	.word	0x20000ce4

08001cd8 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8001cd8:	4b15      	ldr	r3, [pc, #84]	; (8001d30 <vTaskSwitchContext+0x58>)
{
 8001cda:	b530      	push	{r4, r5, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8001cdc:	681a      	ldr	r2, [r3, #0]
 8001cde:	4b15      	ldr	r3, [pc, #84]	; (8001d34 <vTaskSwitchContext+0x5c>)
 8001ce0:	2a00      	cmp	r2, #0
 8001ce2:	d002      	beq.n	8001cea <vTaskSwitchContext+0x12>
		xYieldPending = pdTRUE;
 8001ce4:	2201      	movs	r2, #1
 8001ce6:	601a      	str	r2, [r3, #0]
}
 8001ce8:	bd30      	pop	{r4, r5, pc}
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8001cea:	2514      	movs	r5, #20
 8001cec:	4812      	ldr	r0, [pc, #72]	; (8001d38 <vTaskSwitchContext+0x60>)
		xYieldPending = pdFALSE;
 8001cee:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8001cf0:	6802      	ldr	r2, [r0, #0]
 8001cf2:	4912      	ldr	r1, [pc, #72]	; (8001d3c <vTaskSwitchContext+0x64>)
 8001cf4:	002b      	movs	r3, r5
 8001cf6:	4353      	muls	r3, r2
 8001cf8:	585c      	ldr	r4, [r3, r1]
 8001cfa:	2c00      	cmp	r4, #0
 8001cfc:	d012      	beq.n	8001d24 <vTaskSwitchContext+0x4c>
 8001cfe:	18cc      	adds	r4, r1, r3
 8001d00:	6865      	ldr	r5, [r4, #4]
 8001d02:	3308      	adds	r3, #8
 8001d04:	686d      	ldr	r5, [r5, #4]
 8001d06:	18cb      	adds	r3, r1, r3
 8001d08:	6065      	str	r5, [r4, #4]
 8001d0a:	429d      	cmp	r5, r3
 8001d0c:	d101      	bne.n	8001d12 <vTaskSwitchContext+0x3a>
 8001d0e:	686b      	ldr	r3, [r5, #4]
 8001d10:	6063      	str	r3, [r4, #4]
 8001d12:	2314      	movs	r3, #20
 8001d14:	4353      	muls	r3, r2
 8001d16:	18c9      	adds	r1, r1, r3
 8001d18:	684b      	ldr	r3, [r1, #4]
 8001d1a:	68d9      	ldr	r1, [r3, #12]
 8001d1c:	4b08      	ldr	r3, [pc, #32]	; (8001d40 <vTaskSwitchContext+0x68>)
 8001d1e:	6019      	str	r1, [r3, #0]
 8001d20:	6002      	str	r2, [r0, #0]
}
 8001d22:	e7e1      	b.n	8001ce8 <vTaskSwitchContext+0x10>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8001d24:	2a00      	cmp	r2, #0
 8001d26:	d101      	bne.n	8001d2c <vTaskSwitchContext+0x54>
 8001d28:	b672      	cpsid	i
 8001d2a:	e7fe      	b.n	8001d2a <vTaskSwitchContext+0x52>
 8001d2c:	3a01      	subs	r2, #1
 8001d2e:	e7e1      	b.n	8001cf4 <vTaskSwitchContext+0x1c>
 8001d30:	20000ce4 	.word	0x20000ce4
 8001d34:	20000d68 	.word	0x20000d68
 8001d38:	20000cec 	.word	0x20000cec
 8001d3c:	20000c4c 	.word	0x20000c4c
 8001d40:	20000c40 	.word	0x20000c40

08001d44 <LED_Blinky>:
}

/* USER CODE BEGIN 4 */

void LED_Blinky(void *pvParameters)
{
 8001d44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	TickType_t xDelay = 500 / portTICK_PERIOD_MS;

	for(;;)
	{
		HAL_GPIO_WritePin(Red_LED_GPIO_Port, Red_LED_Pin, GPIO_PIN_RESET);
		HAL_GPIO_WritePin(Blue_LED_GPIO_Port, Blue_LED_Pin, GPIO_PIN_SET);
 8001d46:	24a0      	movs	r4, #160	; 0xa0
		HAL_GPIO_WritePin(Red_LED_GPIO_Port, Red_LED_Pin, GPIO_PIN_RESET);
 8001d48:	2704      	movs	r7, #4
		HAL_GPIO_WritePin(Blue_LED_GPIO_Port, Blue_LED_Pin, GPIO_PIN_SET);
 8001d4a:	2501      	movs	r5, #1
 8001d4c:	2620      	movs	r6, #32
 8001d4e:	05e4      	lsls	r4, r4, #23
		HAL_GPIO_WritePin(Red_LED_GPIO_Port, Red_LED_Pin, GPIO_PIN_RESET);
 8001d50:	0039      	movs	r1, r7
 8001d52:	2200      	movs	r2, #0
 8001d54:	481b      	ldr	r0, [pc, #108]	; (8001dc4 <LED_Blinky+0x80>)
 8001d56:	f7fe fdc3 	bl	80008e0 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(Blue_LED_GPIO_Port, Blue_LED_Pin, GPIO_PIN_SET);
 8001d5a:	002a      	movs	r2, r5
 8001d5c:	0031      	movs	r1, r6
 8001d5e:	0020      	movs	r0, r4
 8001d60:	f7fe fdbe 	bl	80008e0 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(Green_LED_GPIO_Port, Green_LED_Pin, GPIO_PIN_SET);
 8001d64:	002a      	movs	r2, r5
 8001d66:	2180      	movs	r1, #128	; 0x80
 8001d68:	0020      	movs	r0, r4
 8001d6a:	f7fe fdb9 	bl	80008e0 <HAL_GPIO_WritePin>
		vTaskDelay(xDelay);
 8001d6e:	20fa      	movs	r0, #250	; 0xfa
 8001d70:	0040      	lsls	r0, r0, #1
 8001d72:	f7ff ff97 	bl	8001ca4 <vTaskDelay>
		HAL_GPIO_WritePin(Red_LED_GPIO_Port, Red_LED_Pin, GPIO_PIN_SET);
 8001d76:	002a      	movs	r2, r5
 8001d78:	0039      	movs	r1, r7
 8001d7a:	4812      	ldr	r0, [pc, #72]	; (8001dc4 <LED_Blinky+0x80>)
 8001d7c:	f7fe fdb0 	bl	80008e0 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(Blue_LED_GPIO_Port, Blue_LED_Pin, GPIO_PIN_RESET);
 8001d80:	0031      	movs	r1, r6
 8001d82:	0020      	movs	r0, r4
 8001d84:	2200      	movs	r2, #0
 8001d86:	f7fe fdab 	bl	80008e0 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(Green_LED_GPIO_Port, Green_LED_Pin, GPIO_PIN_SET);
 8001d8a:	002a      	movs	r2, r5
 8001d8c:	2180      	movs	r1, #128	; 0x80
 8001d8e:	0020      	movs	r0, r4
 8001d90:	f7fe fda6 	bl	80008e0 <HAL_GPIO_WritePin>
		vTaskDelay(xDelay);
 8001d94:	20fa      	movs	r0, #250	; 0xfa
 8001d96:	0040      	lsls	r0, r0, #1
 8001d98:	f7ff ff84 	bl	8001ca4 <vTaskDelay>
		HAL_GPIO_WritePin(Red_LED_GPIO_Port, Red_LED_Pin, GPIO_PIN_SET);
 8001d9c:	002a      	movs	r2, r5
 8001d9e:	0039      	movs	r1, r7
 8001da0:	4808      	ldr	r0, [pc, #32]	; (8001dc4 <LED_Blinky+0x80>)
 8001da2:	f7fe fd9d 	bl	80008e0 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(Blue_LED_GPIO_Port, Blue_LED_Pin, GPIO_PIN_SET);
 8001da6:	002a      	movs	r2, r5
 8001da8:	0031      	movs	r1, r6
 8001daa:	0020      	movs	r0, r4
 8001dac:	f7fe fd98 	bl	80008e0 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(Green_LED_GPIO_Port, Green_LED_Pin, GPIO_PIN_RESET);
 8001db0:	0020      	movs	r0, r4
 8001db2:	2200      	movs	r2, #0
 8001db4:	2180      	movs	r1, #128	; 0x80
 8001db6:	f7fe fd93 	bl	80008e0 <HAL_GPIO_WritePin>
		vTaskDelay(xDelay);
 8001dba:	20fa      	movs	r0, #250	; 0xfa
 8001dbc:	0040      	lsls	r0, r0, #1
 8001dbe:	f7ff ff71 	bl	8001ca4 <vTaskDelay>
 8001dc2:	e7c5      	b.n	8001d50 <LED_Blinky+0xc>
 8001dc4:	50000400 	.word	0x50000400

08001dc8 <StartDefaultTask>:
  * @param  argument: Not used 
  * @retval None
  */
/* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void const * argument)
{
 8001dc8:	b510      	push	{r4, lr}

  /* USER CODE BEGIN 5 */
  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
 8001dca:	2001      	movs	r0, #1
 8001dcc:	f7ff fb25 	bl	800141a <osDelay>
 8001dd0:	e7fb      	b.n	8001dca <StartDefaultTask+0x2>

08001dd2 <SystemClock_Config>:
{
 8001dd2:	b510      	push	{r4, lr}
 8001dd4:	b0a0      	sub	sp, #128	; 0x80
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8001dd6:	2238      	movs	r2, #56	; 0x38
 8001dd8:	2100      	movs	r1, #0
 8001dda:	a812      	add	r0, sp, #72	; 0x48
 8001ddc:	f000 f9da 	bl	8002194 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8001de0:	2210      	movs	r2, #16
 8001de2:	2100      	movs	r1, #0
 8001de4:	a801      	add	r0, sp, #4
 8001de6:	f000 f9d5 	bl	8002194 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8001dea:	2234      	movs	r2, #52	; 0x34
 8001dec:	2100      	movs	r1, #0
 8001dee:	a805      	add	r0, sp, #20
 8001df0:	f000 f9d0 	bl	8002194 <memset>
  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1);
 8001df4:	2080      	movs	r0, #128	; 0x80
 8001df6:	0080      	lsls	r0, r0, #2
 8001df8:	f7fe fd78 	bl	80008ec <HAL_PWREx_ControlVoltageScaling>
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8001dfc:	2302      	movs	r3, #2
  RCC_OscInitStruct.HSIDiv = RCC_HSI_DIV1;
 8001dfe:	2400      	movs	r4, #0
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8001e00:	9312      	str	r3, [sp, #72]	; 0x48
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8001e02:	33fe      	adds	r3, #254	; 0xfe
 8001e04:	9315      	str	r3, [sp, #84]	; 0x54
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8001e06:	a812      	add	r0, sp, #72	; 0x48
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8001e08:	3bc0      	subs	r3, #192	; 0xc0
 8001e0a:	9317      	str	r3, [sp, #92]	; 0x5c
  RCC_OscInitStruct.HSIDiv = RCC_HSI_DIV1;
 8001e0c:	9416      	str	r4, [sp, #88]	; 0x58
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 8001e0e:	9419      	str	r4, [sp, #100]	; 0x64
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8001e10:	f7fe fd96 	bl	8000940 <HAL_RCC_OscConfig>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8001e14:	2307      	movs	r3, #7
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 8001e16:	0021      	movs	r1, r4
 8001e18:	a801      	add	r0, sp, #4
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8001e1a:	9301      	str	r3, [sp, #4]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
 8001e1c:	9402      	str	r4, [sp, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8001e1e:	9403      	str	r4, [sp, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8001e20:	9404      	str	r4, [sp, #16]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 8001e22:	f7fe ffc7 	bl	8000db4 <HAL_RCC_ClockConfig>
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;
 8001e26:	2380      	movs	r3, #128	; 0x80
 8001e28:	01db      	lsls	r3, r3, #7
 8001e2a:	9305      	str	r3, [sp, #20]
  PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_HSI;
 8001e2c:	2380      	movs	r3, #128	; 0x80
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8001e2e:	a805      	add	r0, sp, #20
  PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_HSI;
 8001e30:	061b      	lsls	r3, r3, #24
 8001e32:	930d      	str	r3, [sp, #52]	; 0x34
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8001e34:	f7ff f896 	bl	8000f64 <HAL_RCCEx_PeriphCLKConfig>
}
 8001e38:	b020      	add	sp, #128	; 0x80
 8001e3a:	bd10      	pop	{r4, pc}

08001e3c <main>:
{
 8001e3c:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001e3e:	2701      	movs	r7, #1
{
 8001e40:	b08b      	sub	sp, #44	; 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001e42:	ac05      	add	r4, sp, #20
  HAL_Init();
 8001e44:	f7fe f9ec 	bl	8000220 <HAL_Init>
  SystemClock_Config();
 8001e48:	f7ff ffc3 	bl	8001dd2 <SystemClock_Config>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001e4c:	2214      	movs	r2, #20
 8001e4e:	2100      	movs	r1, #0
 8001e50:	0020      	movs	r0, r4
 8001e52:	f000 f99f 	bl	8002194 <memset>
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001e56:	2102      	movs	r1, #2
  HAL_GPIO_WritePin(GPIOA, Blue_LED_Pin|Green_LED_Pin, GPIO_PIN_SET);
 8001e58:	20a0      	movs	r0, #160	; 0xa0
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001e5a:	4b4b      	ldr	r3, [pc, #300]	; (8001f88 <main+0x14c>)
  HAL_GPIO_WritePin(GPIOA, Blue_LED_Pin|Green_LED_Pin, GPIO_PIN_SET);
 8001e5c:	05c0      	lsls	r0, r0, #23
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001e5e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001e60:	2500      	movs	r5, #0
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001e62:	433a      	orrs	r2, r7
 8001e64:	635a      	str	r2, [r3, #52]	; 0x34
 8001e66:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001e68:	403a      	ands	r2, r7
 8001e6a:	9203      	str	r2, [sp, #12]
 8001e6c:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001e6e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001e70:	430a      	orrs	r2, r1
 8001e72:	635a      	str	r2, [r3, #52]	; 0x34
 8001e74:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  HAL_GPIO_WritePin(GPIOA, Blue_LED_Pin|Green_LED_Pin, GPIO_PIN_SET);
 8001e76:	003a      	movs	r2, r7
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001e78:	400b      	ands	r3, r1
 8001e7a:	9304      	str	r3, [sp, #16]
  HAL_GPIO_WritePin(GPIOA, Blue_LED_Pin|Green_LED_Pin, GPIO_PIN_SET);
 8001e7c:	319e      	adds	r1, #158	; 0x9e
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001e7e:	9b04      	ldr	r3, [sp, #16]
  HAL_GPIO_WritePin(GPIOA, Blue_LED_Pin|Green_LED_Pin, GPIO_PIN_SET);
 8001e80:	f7fe fd2e 	bl	80008e0 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOB, EN_OTG_Pin|ILIM_HIZ_Pin|CELL_1S_DIS_EN_Pin|CELL_2S_DIS_EN_Pin 
 8001e84:	2200      	movs	r2, #0
 8001e86:	4941      	ldr	r1, [pc, #260]	; (8001f8c <main+0x150>)
 8001e88:	4841      	ldr	r0, [pc, #260]	; (8001f90 <main+0x154>)
 8001e8a:	f7fe fd29 	bl	80008e0 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(Red_LED_GPIO_Port, Red_LED_Pin, GPIO_PIN_SET);
 8001e8e:	003a      	movs	r2, r7
 8001e90:	2104      	movs	r1, #4
 8001e92:	483f      	ldr	r0, [pc, #252]	; (8001f90 <main+0x154>)
 8001e94:	f7fe fd24 	bl	80008e0 <HAL_GPIO_WritePin>
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001e98:	20a0      	movs	r0, #160	; 0xa0
  GPIO_InitStruct.Pin = Blue_LED_Pin|Green_LED_Pin;
 8001e9a:	23a0      	movs	r3, #160	; 0xa0
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001e9c:	0021      	movs	r1, r4
 8001e9e:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = Blue_LED_Pin|Green_LED_Pin;
 8001ea0:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001ea2:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001ea4:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001ea6:	60e5      	str	r5, [r4, #12]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001ea8:	f7fe fc72 	bl	8000790 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = EN_OTG_Pin|Red_LED_Pin|ILIM_HIZ_Pin|CELL_1S_DIS_EN_Pin 
 8001eac:	4b39      	ldr	r3, [pc, #228]	; (8001f94 <main+0x158>)
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001eae:	0021      	movs	r1, r4
 8001eb0:	4837      	ldr	r0, [pc, #220]	; (8001f90 <main+0x154>)
  GPIO_InitStruct.Pin = EN_OTG_Pin|Red_LED_Pin|ILIM_HIZ_Pin|CELL_1S_DIS_EN_Pin 
 8001eb2:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001eb4:	6067      	str	r7, [r4, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001eb6:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001eb8:	60e5      	str	r5, [r4, #12]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001eba:	f7fe fc69 	bl	8000790 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = PROTCHOT_Pin|CHRG_OK_Pin;
 8001ebe:	4b36      	ldr	r3, [pc, #216]	; (8001f98 <main+0x15c>)
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001ec0:	0021      	movs	r1, r4
 8001ec2:	4833      	ldr	r0, [pc, #204]	; (8001f90 <main+0x154>)
  GPIO_InitStruct.Pin = PROTCHOT_Pin|CHRG_OK_Pin;
 8001ec4:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8001ec6:	6065      	str	r5, [r4, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001ec8:	60a5      	str	r5, [r4, #8]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001eca:	f7fe fc61 	bl	8000790 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12;
 8001ece:	23f0      	movs	r3, #240	; 0xf0
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001ed0:	20a0      	movs	r0, #160	; 0xa0
  GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12;
 8001ed2:	015b      	lsls	r3, r3, #5
 8001ed4:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001ed6:	2302      	movs	r3, #2
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001ed8:	0021      	movs	r1, r4
 8001eda:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001edc:	6063      	str	r3, [r4, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001ede:	60a5      	str	r5, [r4, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001ee0:	60e5      	str	r5, [r4, #12]
  GPIO_InitStruct.Alternate = GPIO_AF1_USART1;
 8001ee2:	6127      	str	r7, [r4, #16]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001ee4:	f7fe fc54 	bl	8000790 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 8001ee8:	23c0      	movs	r3, #192	; 0xc0
 8001eea:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8001eec:	3bae      	subs	r3, #174	; 0xae
 8001eee:	6063      	str	r3, [r4, #4]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001ef0:	0021      	movs	r1, r4
  GPIO_InitStruct.Alternate = GPIO_AF6_I2C1;
 8001ef2:	3b0c      	subs	r3, #12
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001ef4:	4826      	ldr	r0, [pc, #152]	; (8001f90 <main+0x154>)
  GPIO_InitStruct.Alternate = GPIO_AF6_I2C1;
 8001ef6:	6123      	str	r3, [r4, #16]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8001ef8:	60a7      	str	r7, [r4, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001efa:	60e5      	str	r5, [r4, #12]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001efc:	f7fe fc48 	bl	8000790 <HAL_GPIO_Init>
  ADC_ChannelConfTypeDef sConfig = {0};
 8001f00:	220c      	movs	r2, #12
 8001f02:	0029      	movs	r1, r5
 8001f04:	0020      	movs	r0, r4
 8001f06:	f000 f945 	bl	8002194 <memset>
  hadc1.Instance = ADC1;
 8001f0a:	4e24      	ldr	r6, [pc, #144]	; (8001f9c <main+0x160>)
 8001f0c:	4b24      	ldr	r3, [pc, #144]	; (8001fa0 <main+0x164>)
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8001f0e:	0030      	movs	r0, r6
  hadc1.Instance = ADC1;
 8001f10:	6033      	str	r3, [r6, #0]
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV2;
 8001f12:	2380      	movs	r3, #128	; 0x80
 8001f14:	05db      	lsls	r3, r3, #23
 8001f16:	6073      	str	r3, [r6, #4]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8001f18:	2304      	movs	r3, #4
 8001f1a:	6173      	str	r3, [r6, #20]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8001f1c:	19f3      	adds	r3, r6, r7
 8001f1e:	77dd      	strb	r5, [r3, #31]
  hadc1.Init.DMAContinuousRequests = DISABLE;
 8001f20:	0033      	movs	r3, r6
 8001f22:	332c      	adds	r3, #44	; 0x2c
 8001f24:	701d      	strb	r5, [r3, #0]
  hadc1.Init.OversamplingMode = DISABLE;
 8001f26:	0033      	movs	r3, r6
 8001f28:	333c      	adds	r3, #60	; 0x3c
 8001f2a:	701d      	strb	r5, [r3, #0]
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 8001f2c:	60b5      	str	r5, [r6, #8]
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8001f2e:	60f5      	str	r5, [r6, #12]
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
 8001f30:	6135      	str	r5, [r6, #16]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 8001f32:	7635      	strb	r5, [r6, #24]
  hadc1.Init.LowPowerAutoPowerOff = DISABLE;
 8001f34:	7675      	strb	r5, [r6, #25]
  hadc1.Init.ContinuousConvMode = DISABLE;
 8001f36:	76b5      	strb	r5, [r6, #26]
  hadc1.Init.NbrOfConversion = 1;
 8001f38:	61f7      	str	r7, [r6, #28]
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8001f3a:	6275      	str	r5, [r6, #36]	; 0x24
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8001f3c:	62b5      	str	r5, [r6, #40]	; 0x28
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8001f3e:	6335      	str	r5, [r6, #48]	; 0x30
  hadc1.Init.SamplingTimeCommon1 = ADC_SAMPLETIME_1CYCLE_5;
 8001f40:	6375      	str	r5, [r6, #52]	; 0x34
  hadc1.Init.SamplingTimeCommon2 = ADC_SAMPLETIME_1CYCLE_5;
 8001f42:	63b5      	str	r5, [r6, #56]	; 0x38
  hadc1.Init.TriggerFrequencyMode = ADC_TRIGGER_FREQ_HIGH;
 8001f44:	64f5      	str	r5, [r6, #76]	; 0x4c
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8001f46:	f7fe f995 	bl	8000274 <HAL_ADC_Init>
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8001f4a:	0021      	movs	r1, r4
 8001f4c:	0030      	movs	r0, r6
  sConfig.Channel = ADC_CHANNEL_0;
 8001f4e:	9705      	str	r7, [sp, #20]
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8001f50:	6065      	str	r5, [r4, #4]
  sConfig.SamplingTime = ADC_SAMPLINGTIME_COMMON_1;
 8001f52:	60a5      	str	r5, [r4, #8]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8001f54:	f7fe fac6 	bl	80004e4 <HAL_ADC_ConfigChannel>
  xTaskCreate(
 8001f58:	2302      	movs	r3, #2
 8001f5a:	4912      	ldr	r1, [pc, #72]	; (8001fa4 <main+0x168>)
 8001f5c:	9300      	str	r3, [sp, #0]
 8001f5e:	2280      	movs	r2, #128	; 0x80
 8001f60:	002b      	movs	r3, r5
 8001f62:	9501      	str	r5, [sp, #4]
 8001f64:	4810      	ldr	r0, [pc, #64]	; (8001fa8 <main+0x16c>)
 8001f66:	f7ff fcc1 	bl	80018ec <xTaskCreate>
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
 8001f6a:	0022      	movs	r2, r4
 8001f6c:	4b0f      	ldr	r3, [pc, #60]	; (8001fac <main+0x170>)
 8001f6e:	cb43      	ldmia	r3!, {r0, r1, r6}
 8001f70:	c243      	stmia	r2!, {r0, r1, r6}
 8001f72:	cb03      	ldmia	r3!, {r0, r1}
 8001f74:	c203      	stmia	r2!, {r0, r1}
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
 8001f76:	0029      	movs	r1, r5
 8001f78:	0020      	movs	r0, r4
 8001f7a:	f7ff fa36 	bl	80013ea <osThreadCreate>
 8001f7e:	4b0c      	ldr	r3, [pc, #48]	; (8001fb0 <main+0x174>)
 8001f80:	6018      	str	r0, [r3, #0]
  osKernelStart();
 8001f82:	f7ff fa2d 	bl	80013e0 <osKernelStart>
 8001f86:	e7fe      	b.n	8001f86 <main+0x14a>
 8001f88:	40021000 	.word	0x40021000
 8001f8c:	00000b31 	.word	0x00000b31
 8001f90:	50000400 	.word	0x50000400
 8001f94:	00000b35 	.word	0x00000b35
 8001f98:	00001002 	.word	0x00001002
 8001f9c:	20000d74 	.word	0x20000d74
 8001fa0:	40012400 	.word	0x40012400
 8001fa4:	080021d5 	.word	0x080021d5
 8001fa8:	08001d45 	.word	0x08001d45
 8001fac:	080021bc 	.word	0x080021bc
 8001fb0:	20000d70 	.word	0x20000d70

08001fb4 <HAL_TIM_PeriodElapsedCallback>:
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM2) {
 8001fb4:	2380      	movs	r3, #128	; 0x80
 8001fb6:	6802      	ldr	r2, [r0, #0]
{
 8001fb8:	b510      	push	{r4, lr}
  if (htim->Instance == TIM2) {
 8001fba:	05db      	lsls	r3, r3, #23
 8001fbc:	429a      	cmp	r2, r3
 8001fbe:	d101      	bne.n	8001fc4 <HAL_TIM_PeriodElapsedCallback+0x10>
    HAL_IncTick();
 8001fc0:	f7fe f942 	bl	8000248 <HAL_IncTick>
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 8001fc4:	bd10      	pop	{r4, pc}
	...

08001fc8 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8001fc8:	b507      	push	{r0, r1, r2, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001fca:	2001      	movs	r0, #1
 8001fcc:	4b0b      	ldr	r3, [pc, #44]	; (8001ffc <HAL_MspInit+0x34>)
 8001fce:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8001fd0:	4301      	orrs	r1, r0
 8001fd2:	6419      	str	r1, [r3, #64]	; 0x40
  __HAL_RCC_PWR_CLK_ENABLE();
 8001fd4:	2180      	movs	r1, #128	; 0x80
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001fd6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  __HAL_RCC_PWR_CLK_ENABLE();
 8001fd8:	0549      	lsls	r1, r1, #21
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001fda:	4002      	ands	r2, r0
 8001fdc:	9200      	str	r2, [sp, #0]
 8001fde:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8001fe0:	6bda      	ldr	r2, [r3, #60]	; 0x3c

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 3, 0);
 8001fe2:	3803      	subs	r0, #3
  __HAL_RCC_PWR_CLK_ENABLE();
 8001fe4:	430a      	orrs	r2, r1
 8001fe6:	63da      	str	r2, [r3, #60]	; 0x3c
 8001fe8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  HAL_NVIC_SetPriority(PendSV_IRQn, 3, 0);
 8001fea:	2200      	movs	r2, #0
  __HAL_RCC_PWR_CLK_ENABLE();
 8001fec:	400b      	ands	r3, r1
 8001fee:	9301      	str	r3, [sp, #4]
  HAL_NVIC_SetPriority(PendSV_IRQn, 3, 0);
 8001ff0:	2103      	movs	r1, #3
  __HAL_RCC_PWR_CLK_ENABLE();
 8001ff2:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(PendSV_IRQn, 3, 0);
 8001ff4:	f7fe fb92 	bl	800071c <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8001ff8:	bd07      	pop	{r0, r1, r2, pc}
 8001ffa:	46c0      	nop			; (mov r8, r8)
 8001ffc:	40021000 	.word	0x40021000

08002000 <HAL_ADC_MspInit>:
* This function configures the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8002000:	b510      	push	{r4, lr}
 8002002:	0004      	movs	r4, r0
 8002004:	b088      	sub	sp, #32

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8002006:	2214      	movs	r2, #20
 8002008:	2100      	movs	r1, #0
 800200a:	a803      	add	r0, sp, #12
 800200c:	f000 f8c2 	bl	8002194 <memset>
  if(hadc->Instance==ADC1)
 8002010:	4b10      	ldr	r3, [pc, #64]	; (8002054 <HAL_ADC_MspInit+0x54>)
 8002012:	6822      	ldr	r2, [r4, #0]
 8002014:	429a      	cmp	r2, r3
 8002016:	d11a      	bne.n	800204e <HAL_ADC_MspInit+0x4e>
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_ADC_CLK_ENABLE();
 8002018:	2080      	movs	r0, #128	; 0x80
 800201a:	4b0f      	ldr	r3, [pc, #60]	; (8002058 <HAL_ADC_MspInit+0x58>)
 800201c:	0340      	lsls	r0, r0, #13
 800201e:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8002020:	4301      	orrs	r1, r0
 8002022:	6419      	str	r1, [r3, #64]	; 0x40
  
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8002024:	2101      	movs	r1, #1
    __HAL_RCC_ADC_CLK_ENABLE();
 8002026:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002028:	4002      	ands	r2, r0
 800202a:	9201      	str	r2, [sp, #4]
 800202c:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800202e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    */
    GPIO_InitStruct.Pin = Cell_4S_ADC_Pin|Cell_3S_ADC_Pin|Cell_2S_ADC_Pin|Cell_1S_ADC_Pin 
                          |BAT_ADC_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8002030:	20a0      	movs	r0, #160	; 0xa0
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8002032:	430a      	orrs	r2, r1
 8002034:	635a      	str	r2, [r3, #52]	; 0x34
 8002036:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8002038:	05c0      	lsls	r0, r0, #23
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800203a:	400b      	ands	r3, r1
 800203c:	9302      	str	r3, [sp, #8]
 800203e:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = Cell_4S_ADC_Pin|Cell_3S_ADC_Pin|Cell_2S_ADC_Pin|Cell_1S_ADC_Pin 
 8002040:	231f      	movs	r3, #31
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8002042:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Pin = Cell_4S_ADC_Pin|Cell_3S_ADC_Pin|Cell_2S_ADC_Pin|Cell_1S_ADC_Pin 
 8002044:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8002046:	3b1c      	subs	r3, #28
 8002048:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800204a:	f7fe fba1 	bl	8000790 <HAL_GPIO_Init>
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }

}
 800204e:	b008      	add	sp, #32
 8002050:	bd10      	pop	{r4, pc}
 8002052:	46c0      	nop			; (mov r8, r8)
 8002054:	40012400 	.word	0x40012400
 8002058:	40021000 	.word	0x40021000

0800205c <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig(). 
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800205c:	b530      	push	{r4, r5, lr}
  
  /* Enable the TIM2 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM2_IRQn); 
  
  /* Enable TIM2 clock */
  __HAL_RCC_TIM2_CLK_ENABLE();
 800205e:	2501      	movs	r5, #1
{
 8002060:	b087      	sub	sp, #28
 8002062:	0001      	movs	r1, r0
  HAL_NVIC_SetPriority(TIM2_IRQn, TickPriority ,0); 
 8002064:	2200      	movs	r2, #0
 8002066:	200f      	movs	r0, #15
 8002068:	f7fe fb58 	bl	800071c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM2_IRQn); 
 800206c:	200f      	movs	r0, #15
 800206e:	f7fe fb85 	bl	800077c <HAL_NVIC_EnableIRQ>
  __HAL_RCC_TIM2_CLK_ENABLE();
 8002072:	4b14      	ldr	r3, [pc, #80]	; (80020c4 <HAL_InitTick+0x68>)
  
  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8002074:	4669      	mov	r1, sp
  __HAL_RCC_TIM2_CLK_ENABLE();
 8002076:	6bda      	ldr	r2, [r3, #60]	; 0x3c
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8002078:	a802      	add	r0, sp, #8
  __HAL_RCC_TIM2_CLK_ENABLE();
 800207a:	432a      	orrs	r2, r5
 800207c:	63da      	str	r2, [r3, #60]	; 0x3c
 800207e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002080:	402b      	ands	r3, r5
 8002082:	9301      	str	r3, [sp, #4]
 8002084:	9b01      	ldr	r3, [sp, #4]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8002086:	f7fe ff53 	bl	8000f30 <HAL_RCC_GetClockConfig>
  
  /* Compute TIM2 clock */
  uwTimclock = HAL_RCC_GetPCLK1Freq();
 800208a:	f7fe ff3d 	bl	8000f08 <HAL_RCC_GetPCLK1Freq>
   
  /* Compute the prescaler value to have TIM2 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
  
  /* Initialize TIM2 */
  htim2.Instance = TIM2;
 800208e:	2380      	movs	r3, #128	; 0x80
 8002090:	4c0d      	ldr	r4, [pc, #52]	; (80020c8 <HAL_InitTick+0x6c>)
 8002092:	05db      	lsls	r3, r3, #23
 8002094:	6023      	str	r3, [r4, #0]
  + Period = [(TIM2CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim2.Init.Period = (1000000 / 1000) - 1;
 8002096:	4b0d      	ldr	r3, [pc, #52]	; (80020cc <HAL_InitTick+0x70>)
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 8002098:	490d      	ldr	r1, [pc, #52]	; (80020d0 <HAL_InitTick+0x74>)
  htim2.Init.Period = (1000000 / 1000) - 1;
 800209a:	60e3      	str	r3, [r4, #12]
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 800209c:	f7fe f834 	bl	8000108 <__udivsi3>
  htim2.Init.Prescaler = uwPrescalerValue;
  htim2.Init.ClockDivision = 0;
 80020a0:	2300      	movs	r3, #0
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 80020a2:	3801      	subs	r0, #1
  htim2.Init.Prescaler = uwPrescalerValue;
 80020a4:	6060      	str	r0, [r4, #4]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  if(HAL_TIM_Base_Init(&htim2) == HAL_OK)
 80020a6:	0020      	movs	r0, r4
  htim2.Init.ClockDivision = 0;
 80020a8:	6123      	str	r3, [r4, #16]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 80020aa:	60a3      	str	r3, [r4, #8]
  if(HAL_TIM_Base_Init(&htim2) == HAL_OK)
 80020ac:	f7ff f97a 	bl	80013a4 <HAL_TIM_Base_Init>
 80020b0:	0003      	movs	r3, r0
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim2);
  }
  
  /* Return function status */
  return HAL_ERROR;
 80020b2:	0028      	movs	r0, r5
  if(HAL_TIM_Base_Init(&htim2) == HAL_OK)
 80020b4:	2b00      	cmp	r3, #0
 80020b6:	d102      	bne.n	80020be <HAL_InitTick+0x62>
    return HAL_TIM_Base_Start_IT(&htim2);
 80020b8:	0020      	movs	r0, r4
 80020ba:	f7ff f857 	bl	800116c <HAL_TIM_Base_Start_IT>
}
 80020be:	b007      	add	sp, #28
 80020c0:	bd30      	pop	{r4, r5, pc}
 80020c2:	46c0      	nop			; (mov r8, r8)
 80020c4:	40021000 	.word	0x40021000
 80020c8:	20000dd8 	.word	0x20000dd8
 80020cc:	000003e7 	.word	0x000003e7
 80020d0:	000f4240 	.word	0x000f4240

080020d4 <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 80020d4:	4770      	bx	lr

080020d6 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 80020d6:	e7fe      	b.n	80020d6 <HardFault_Handler>

080020d8 <TIM2_IRQHandler>:

/**
  * @brief This function handles TIM2 global interrupt.
  */
void TIM2_IRQHandler(void)
{
 80020d8:	b510      	push	{r4, lr}
  /* USER CODE BEGIN TIM2_IRQn 0 */

  /* USER CODE END TIM2_IRQn 0 */
  HAL_TIM_IRQHandler(&htim2);
 80020da:	4802      	ldr	r0, [pc, #8]	; (80020e4 <TIM2_IRQHandler+0xc>)
 80020dc:	f7ff f85e 	bl	800119c <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM2_IRQn 1 */

  /* USER CODE END TIM2_IRQn 1 */
}
 80020e0:	bd10      	pop	{r4, pc}
 80020e2:	46c0      	nop			; (mov r8, r8)
 80020e4:	20000dd8 	.word	0x20000dd8

080020e8 <SystemInit>:
{
  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80020e8:	2280      	movs	r2, #128	; 0x80
 80020ea:	4b02      	ldr	r3, [pc, #8]	; (80020f4 <SystemInit+0xc>)
 80020ec:	0512      	lsls	r2, r2, #20
 80020ee:	609a      	str	r2, [r3, #8]
#endif
}
 80020f0:	4770      	bx	lr
 80020f2:	46c0      	nop			; (mov r8, r8)
 80020f4:	e000ed00 	.word	0xe000ed00

080020f8 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 80020f8:	480d      	ldr	r0, [pc, #52]	; (8002130 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 80020fa:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 80020fc:	2100      	movs	r1, #0
  b LoopCopyDataInit
 80020fe:	e003      	b.n	8002108 <LoopCopyDataInit>

08002100 <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 8002100:	4b0c      	ldr	r3, [pc, #48]	; (8002134 <LoopForever+0x6>)
  ldr r3, [r3, r1]
 8002102:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 8002104:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 8002106:	3104      	adds	r1, #4

08002108 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 8002108:	480b      	ldr	r0, [pc, #44]	; (8002138 <LoopForever+0xa>)
  ldr r3, =_edata
 800210a:	4b0c      	ldr	r3, [pc, #48]	; (800213c <LoopForever+0xe>)
  adds r2, r0, r1
 800210c:	1842      	adds	r2, r0, r1
  cmp r2, r3
 800210e:	429a      	cmp	r2, r3
  bcc CopyDataInit
 8002110:	d3f6      	bcc.n	8002100 <CopyDataInit>
  ldr r2, =_sbss
 8002112:	4a0b      	ldr	r2, [pc, #44]	; (8002140 <LoopForever+0x12>)
  b LoopFillZerobss
 8002114:	e002      	b.n	800211c <LoopFillZerobss>

08002116 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 8002116:	2300      	movs	r3, #0
  str  r3, [r2]
 8002118:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800211a:	3204      	adds	r2, #4

0800211c <LoopFillZerobss>:


LoopFillZerobss:
  ldr r3, = _ebss
 800211c:	4b09      	ldr	r3, [pc, #36]	; (8002144 <LoopForever+0x16>)
  cmp r2, r3
 800211e:	429a      	cmp	r2, r3
  bcc FillZerobss
 8002120:	d3f9      	bcc.n	8002116 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 8002122:	f7ff ffe1 	bl	80020e8 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 8002126:	f000 f811 	bl	800214c <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 800212a:	f7ff fe87 	bl	8001e3c <main>

0800212e <LoopForever>:

LoopForever:
    b LoopForever
 800212e:	e7fe      	b.n	800212e <LoopForever>
  ldr   r0, =_estack
 8002130:	20009000 	.word	0x20009000
  ldr r3, =_sidata
 8002134:	08002254 	.word	0x08002254
  ldr r0, =_sdata
 8002138:	20000000 	.word	0x20000000
  ldr r3, =_edata
 800213c:	2000000c 	.word	0x2000000c
  ldr r2, =_sbss
 8002140:	2000000c 	.word	0x2000000c
  ldr r3, = _ebss
 8002144:	20000e18 	.word	0x20000e18

08002148 <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8002148:	e7fe      	b.n	8002148 <ADC1_COMP_IRQHandler>
	...

0800214c <__libc_init_array>:
 800214c:	b570      	push	{r4, r5, r6, lr}
 800214e:	2600      	movs	r6, #0
 8002150:	4d0c      	ldr	r5, [pc, #48]	; (8002184 <__libc_init_array+0x38>)
 8002152:	4c0d      	ldr	r4, [pc, #52]	; (8002188 <__libc_init_array+0x3c>)
 8002154:	1b64      	subs	r4, r4, r5
 8002156:	10a4      	asrs	r4, r4, #2
 8002158:	42a6      	cmp	r6, r4
 800215a:	d109      	bne.n	8002170 <__libc_init_array+0x24>
 800215c:	2600      	movs	r6, #0
 800215e:	f000 f821 	bl	80021a4 <_init>
 8002162:	4d0a      	ldr	r5, [pc, #40]	; (800218c <__libc_init_array+0x40>)
 8002164:	4c0a      	ldr	r4, [pc, #40]	; (8002190 <__libc_init_array+0x44>)
 8002166:	1b64      	subs	r4, r4, r5
 8002168:	10a4      	asrs	r4, r4, #2
 800216a:	42a6      	cmp	r6, r4
 800216c:	d105      	bne.n	800217a <__libc_init_array+0x2e>
 800216e:	bd70      	pop	{r4, r5, r6, pc}
 8002170:	00b3      	lsls	r3, r6, #2
 8002172:	58eb      	ldr	r3, [r5, r3]
 8002174:	4798      	blx	r3
 8002176:	3601      	adds	r6, #1
 8002178:	e7ee      	b.n	8002158 <__libc_init_array+0xc>
 800217a:	00b3      	lsls	r3, r6, #2
 800217c:	58eb      	ldr	r3, [r5, r3]
 800217e:	4798      	blx	r3
 8002180:	3601      	adds	r6, #1
 8002182:	e7f2      	b.n	800216a <__libc_init_array+0x1e>
 8002184:	0800224c 	.word	0x0800224c
 8002188:	0800224c 	.word	0x0800224c
 800218c:	0800224c 	.word	0x0800224c
 8002190:	08002250 	.word	0x08002250

08002194 <memset>:
 8002194:	0003      	movs	r3, r0
 8002196:	1882      	adds	r2, r0, r2
 8002198:	4293      	cmp	r3, r2
 800219a:	d100      	bne.n	800219e <memset+0xa>
 800219c:	4770      	bx	lr
 800219e:	7019      	strb	r1, [r3, #0]
 80021a0:	3301      	adds	r3, #1
 80021a2:	e7f9      	b.n	8002198 <memset+0x4>

080021a4 <_init>:
 80021a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80021a6:	46c0      	nop			; (mov r8, r8)
 80021a8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80021aa:	bc08      	pop	{r3}
 80021ac:	469e      	mov	lr, r3
 80021ae:	4770      	bx	lr

080021b0 <_fini>:
 80021b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80021b2:	46c0      	nop			; (mov r8, r8)
 80021b4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80021b6:	bc08      	pop	{r3}
 80021b8:	469e      	mov	lr, r3
 80021ba:	4770      	bx	lr
